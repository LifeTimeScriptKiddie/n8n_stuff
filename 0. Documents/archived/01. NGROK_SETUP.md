# Ngrok Integration Setup Guide
**n8n Reconnaissance Platform - Bug Bounty Edition**

---

## Overview

This guide explains how to integrate ngrok tunneling with your n8n reconnaissance platform to enable:
- **Out-of-Band Application Security Testing (OAST)** - Detect blind vulnerabilities
- **External webhook callbacks** - Receive results from async scanning tools
- **Public webhook access** - Allow external services to trigger workflows

---

## Table of Contents

1. [Why Use Ngrok](#why-use-ngrok)
2. [Prerequisites](#prerequisites)
3. [Quick Start (5 Minutes)](#quick-start)
4. [Detailed Setup](#detailed-setup)
5. [Security Configuration](#security-configuration)
6. [Testing & Validation](#testing--validation)
7. [Workflow Integration](#workflow-integration)
8. [Troubleshooting](#troubleshooting)
9. [Production Considerations](#production-considerations)

---

## Why Use Ngrok

### Use Cases for Bug Bounty Hunting

**1. OAST (Out-of-Band Application Security Testing)**
```
Traditional Detection:     OAST Detection:
Target ‚Üí Response         Target ‚Üí External Request ‚Üí Your Server
Visible ‚úÖ                 Invisible to traditional tools ‚ùå
                          Detectable with ngrok ‚úÖ

Examples:
- Blind SSRF
- Blind XSS
- Blind XXE
- DNS exfiltration
- Log4Shell callbacks
```

**2. Async Tool Callbacks**
```
Without ngrok:                     With ngrok:
Run scan ‚Üí Wait ‚Üí Parse output    Run scan ‚Üí Continue work ‚Üí Receive callback
Blocking ‚ùå                         Non-blocking ‚úÖ
```

**3. External Service Integration**
```
External Service ‚Üí ngrok tunnel ‚Üí localhost:5678 ‚Üí n8n workflow
GitHub webhooks, Slack events, API callbacks, etc.
```

---

## Prerequisites

### Required:
- ‚úÖ n8n reconnaissance platform running (see README.md)
- ‚úÖ Docker and docker-compose installed
- ‚úÖ Internet connection
- ‚úÖ ngrok account (free tier is sufficient for testing)

### Recommended:
- üí∞ ngrok Pro account ($8/month) for production use
- üîê Strong understanding of webhook security
- üìä Monitoring/alerting setup

---

## Quick Start

### Step 1: Get ngrok Authtoken

1. Sign up at https://ngrok.com (free)
2. Go to dashboard: https://dashboard.ngrok.com
3. Navigate to "Your Authtoken" section
4. Copy the authtoken (looks like: `2abc...xyz_1234...5678`)

### Step 2: Configure Environment

Add these lines to your `.env` file:

```bash
# ============================================================================
# NGROK TUNNEL CONFIGURATION
# ============================================================================

# Enable ngrok tunneling
N8N_TUNNEL_ENABLED=true

# Your ngrok authtoken (from https://dashboard.ngrok.com)
N8N_TUNNEL_NGROK_AUTH_TOKEN=YOUR_AUTHTOKEN_HERE

# Security: Callback secret for webhook validation
NGROK_CALLBACK_SECRET=REPLACE_WITH_RANDOM_SECRET_TOKEN

# Optional: Static subdomain (requires ngrok Pro)
# N8N_TUNNEL_NGROK_SUBDOMAIN=my-recon-platform
```

**Generate a secure callback secret:**
```bash
# Option 1: Using openssl
openssl rand -hex 32

# Option 2: Using /dev/urandom
head -c 32 /dev/urandom | base64

# Add the output to .env as NGROK_CALLBACK_SECRET
```

### Step 3: Restart Container

```bash
cd /Users/tester/Documents/CodeCollector/n8n
docker compose restart n8n-recon
```

### Step 4: Verify Tunnel

```bash
# Check logs for tunnel initialization
docker compose logs n8n-recon | grep -i tunnel

# Expected output:
# "Tunnel started on ..." or similar
```

### Step 5: Check n8n GUI

1. Open n8n: http://localhost:5678
2. Create a new workflow
3. Add a "Webhook" node
4. Look at the Test URL field
5. **You should see:** `https://RANDOM-ID.ngrok.io/webhook-test/...`
   (instead of `http://localhost:5678/webhook-test/...`)

**‚úÖ If you see ngrok.io URL ‚Üí Setup successful!**

---

## Detailed Setup

### Understanding Ngrok Tiers

| Feature | Free Tier | Pro Tier ($8/mo) |
|---------|-----------|------------------|
| **URL Type** | Random (changes on restart) | Static subdomain |
| **Concurrent Tunnels** | 1 | 10 |
| **Connections/min** | 40 | 120 |
| **IP Whitelisting** | ‚ùå No | ‚úÖ Yes |
| **OAuth** | ‚ùå No | ‚úÖ Yes |
| **Custom Domains** | ‚ùå No | ‚úÖ Yes |
| **Best For** | Development/Testing | Production/Multi-user |

### Configuration Options

#### Option 1: Always-On Mode (Convenient)

**Use when:** Single-user development, paid ngrok tier with security features

```env
N8N_TUNNEL_ENABLED=true
N8N_TUNNEL_NGROK_AUTH_TOKEN=your_token
```

**Pros:**
- ‚úÖ Tunnel always available
- ‚úÖ Consistent URL (with paid tier)
- ‚úÖ No manual management

**Cons:**
- ‚ùå Constant security exposure
- ‚ùå Counts toward connection limits
- ‚ùå Random URL changes on free tier

#### Option 2: On-Demand Mode (Secure)

**Use when:** Production environment, free tier, security-conscious

**Implementation:**
- Set `N8N_TUNNEL_ENABLED=false` in .env
- Use ngrok manager workflow (to be created)
- Start tunnel only when needed for specific scans
- Stop tunnel after scan completes

**Pros:**
- ‚úÖ Minimal exposure window
- ‚úÖ Better security posture
- ‚úÖ Resource efficient

**Cons:**
- ‚ùå Requires workflow management
- ‚ùå More complex setup
- ‚ùå Manual coordination needed

**We'll implement on-demand mode in the ngrok manager workflow**

---

## Security Configuration

### CRITICAL: Webhook Security

‚ö†Ô∏è **WARNING:** ngrok exposes your local n8n to the internet. Proper security is MANDATORY.

### Security Layers

#### Layer 1: Callback Token Validation

**Every webhook that receives external data MUST validate the secret token.**

**n8n Function Node Example:**
```javascript
// Place this at the start of any webhook-receiving workflow
const receivedToken = $input.item.json.headers['x-callback-token'];
const expectedToken = process.env.NGROK_CALLBACK_SECRET;

if (receivedToken !== expectedToken) {
  throw new Error('Unauthorized: Invalid callback token');
}

// Continue processing if token is valid
return $input.all();
```

#### Layer 2: Input Sanitization

**Treat ALL webhook data as untrusted.**

```javascript
// Sanitize inputs before using in commands or SQL
const sanitize = (input) => {
  if (typeof input !== 'string') return '';

  // Remove shell metacharacters
  return input
    .replace(/[;&|`$()]/g, '')
    .replace(/\.\./g, '')
    .trim();
};

const safeTarget = sanitize($json.target);
const safeUrl = sanitize($json.url);
```

#### Layer 3: Rate Limiting

**Implement in webhook receiver workflows:**

```javascript
// Track requests per IP
const requestCache = {}; // In production, use Redis
const clientIP = $json.headers['x-forwarded-for'] || 'unknown';
const now = Date.now();
const timeWindow = 60000; // 1 minute
const maxRequests = 10;

if (!requestCache[clientIP]) {
  requestCache[clientIP] = [];
}

// Clean old requests
requestCache[clientIP] = requestCache[clientIP].filter(
  t => now - t < timeWindow
);

// Check rate limit
if (requestCache[clientIP].length >= maxRequests) {
  throw new Error('Rate limit exceeded');
}

requestCache[clientIP].push(now);
```

#### Layer 4: IP Whitelisting (Paid Tier Only)

**Via ngrok dashboard:**
1. Go to https://dashboard.ngrok.com/cloud-edge/ip-restrictions
2. Add allowed IP ranges:
   ```
   # Example: Only allow specific services
   140.82.112.0/20  # GitHub webhooks
   54.187.0.0/16    # AWS services
   ```

#### Layer 5: Basic Auth (Already Active)

Your n8n instance already has basic auth enabled:
```env
N8N_BASIC_AUTH_ACTIVE=true
N8N_BASIC_AUTH_USER=admin
N8N_BASIC_AUTH_PASSWORD=<your_password>
```

This protects the n8n GUI, but **webhooks bypass basic auth by design.**

---

## Testing & Validation

### Test 1: Basic Tunnel Connectivity

```bash
# Get your ngrok URL from n8n GUI
NGROK_URL="https://YOUR-ID.ngrok.io"

# Test health endpoint
curl -v "${NGROK_URL}/healthz"

# Expected: HTTP 200 OK
```

### Test 2: Webhook Callback (Without Security)

**Create a simple test workflow in n8n:**

1. Add "Webhook" trigger node
2. Set path to: `test-callback`
3. Save and activate workflow
4. Copy the production webhook URL

**Test from external machine:**
```bash
curl -X POST https://YOUR-ID.ngrok.io/webhook/test-callback \
  -H "Content-Type: application/json" \
  -d '{"test": "hello from internet"}'
```

**Check n8n executions:**
- Should see new execution
- Should see the JSON payload

### Test 3: Webhook Security (With Token)

**Modify workflow to add token validation function node (see Security section)**

**Test with wrong token (should fail):**
```bash
curl -X POST https://YOUR-ID.ngrok.io/webhook/test-callback \
  -H "Content-Type: application/json" \
  -H "X-Callback-Token: wrong_token" \
  -d '{"test": "unauthorized"}'

# Expected: Error 500 or 403
```

**Test with correct token (should succeed):**
```bash
curl -X POST https://YOUR-ID.ngrok.io/webhook/test-callback \
  -H "Content-Type: application/json" \
  -H "X-Callback-Token: YOUR_ACTUAL_SECRET_TOKEN" \
  -d '{"test": "authorized"}'

# Expected: Success, execution appears in n8n
```

### Test 4: OAST Detection (Nuclei)

**Create a test target with blind SSRF vulnerability, then:**

```bash
# Run nuclei with your ngrok callback URL
docker compose exec n8n-recon nuclei \
  -u "http://vulnerable-target.com/ssrf-endpoint" \
  -t /root/.nuclei-templates/http/vulnerabilities/ \
  -iserver "https://YOUR-ID.ngrok.io/webhook/oast-callback" \
  -header "X-Callback-Token: YOUR_SECRET"

# If blind SSRF exists:
# 1. Target makes request to ngrok URL
# 2. Request appears in n8n webhook executions
# 3. Vulnerability confirmed!
```

---

## Workflow Integration

### Affected Workflows

#### Phase 2: Active Reconnaissance
**File:** `workflows/phase2_active_recon.json`

**Integration points:**
- Optional: gowitness callbacks
- Optional: Custom async scanning tools

#### Phase 3: Vulnerability Assessment
**File:** `workflows/phase3_vulnerability_assessment.json`

**Primary use case: Nuclei OAST**

**Modification needed:**
```javascript
// In the nuclei execution node, add iserver flag
const ngrokUrl = process.env.N8N_WEBHOOK_URL || 'http://localhost:5678';
const callbackUrl = `${ngrokUrl}/webhook/oast-callback`;
const callbackToken = process.env.NGROK_CALLBACK_SECRET;

const nucleiCommand = `
nuclei -u ${target} \
  -severity high,critical \
  -iserver "${callbackUrl}" \
  -header "X-Callback-Token: ${callbackToken}" \
  -json
`;
```

### New Workflows to Create

#### 1. Webhook Callback Receiver
**File:** `workflows/webhook_callback_receiver.json`

**Purpose:** Receive and process OAST callbacks

**Nodes:**
1. Webhook trigger (`/webhook/oast-callback`)
2. Token validator (Function node)
3. Payload parser (Function node)
4. Database writer (Postgres node)
5. Notification sender (Slack/Discord - optional)

#### 2. Ngrok Manager
**File:** `workflows/ngrok_manager.json`

**Purpose:** Start/stop ngrok tunnel on-demand

**Nodes:**
1. Manual trigger or HTTP webhook
2. Start ngrok (Execute Command)
3. Get tunnel URL (HTTP Request to ngrok API)
4. Return URL to caller
5. Stop ngrok (Execute Command)

**We'll create these workflows in subsequent steps.**

---

## Troubleshooting

### Issue 1: Tunnel Not Starting

**Symptoms:**
- Webhook URLs still show `localhost:5678`
- No ngrok process in container

**Diagnosis:**
```bash
# Check environment variables
docker compose exec n8n-recon env | grep TUNNEL

# Expected output:
# N8N_TUNNEL_ENABLED=true
# N8N_TUNNEL_NGROK_AUTH_TOKEN=<your_token>

# Check logs
docker compose logs n8n-recon | grep -i "tunnel\|ngrok"
```

**Solutions:**
1. Verify `N8N_TUNNEL_ENABLED=true` (not "True" or "1")
2. Ensure authtoken is correct (copy-paste from dashboard)
3. Restart container: `docker compose restart n8n-recon`
4. Check ngrok account limits (free tier: 1 online agent)

### Issue 2: Tunnel Drops During Scan

**Symptoms:**
- Webhook callbacks stop working mid-scan
- ngrok URL returns 502 Bad Gateway

**Diagnosis:**
```bash
# Check if ngrok process is running
docker compose exec n8n-recon ps aux | grep ngrok

# Check ngrok agent API
curl http://localhost:4040/api/tunnels
```

**Solutions:**
1. **Free tier:** Accept that random disconnects happen, implement retry logic
2. **Paid tier:** Use static subdomain, configure auto-restart
3. Implement tunnel health monitoring (see Monitoring section)
4. Use on-demand mode to minimize exposure time

### Issue 3: Callbacks Not Received

**Symptoms:**
- External tool reports success
- No execution appears in n8n

**Diagnosis:**
```bash
# Test ngrok URL directly
curl https://YOUR-ID.ngrok.io/webhook/your-path

# Check n8n logs for errors
docker compose logs n8n-recon --tail=100

# Verify workflow is activated
# (check n8n GUI - toggle should be ON)
```

**Solutions:**
1. Ensure workflow is **activated** (not just saved)
2. Verify callback URL path matches workflow path exactly
3. Check token validation isn't rejecting requests
4. Review ngrok dashboard for connection attempts

### Issue 4: "Too Many Connections"

**Symptoms:**
- ngrok returns 429 error
- Free tier limit reached

**Solutions:**
1. Upgrade to paid tier (120 conn/min vs 40)
2. Implement request queuing/throttling
3. Use on-demand mode to reduce constant traffic
4. Spread scans across longer time periods

### Issue 5: Security Breach Detected

**Symptoms:**
- Unexpected executions in n8n
- Unknown IP addresses in logs
- Suspicious database entries

**Immediate Actions:**
1. **DISABLE TUNNEL IMMEDIATELY:**
   ```bash
   # Edit .env
   N8N_TUNNEL_ENABLED=false

   # Restart
   docker compose restart n8n-recon
   ```

2. **Review audit logs:**
   ```sql
   SELECT * FROM audit_log
   WHERE timestamp > NOW() - INTERVAL '24 hours'
   ORDER BY timestamp DESC;
   ```

3. **Change all credentials:**
   - Rotate NGROK_CALLBACK_SECRET
   - Change N8N_BASIC_AUTH_PASSWORD
   - Review API keys

4. **Investigate:**
   - Check execution history
   - Review database for malicious data
   - Check for privilege escalation

---

## Production Considerations

### When to Use Free Tier

‚úÖ **Good for:**
- Development and testing
- Learning OAST techniques
- Single-user setups
- Infrequent scanning

‚ùå **Not suitable for:**
- Production deployments
- Multi-user platforms
- 24/7 monitoring
- Commercial services

### When to Upgrade to Pro ($8/month)

‚úÖ **Upgrade when you need:**
- Static subdomain (URL doesn't change)
- IP whitelisting (security)
- Higher connection limits
- OAuth authentication
- Custom domains
- Better reliability

### Migration to Self-Hosted (Future)

**When you outgrow ngrok, migrate to:**

1. **VPS with Public IP** ($5-20/month)
   - DigitalOcean, Linode, Hetzner, Vultr

2. **Reverse Proxy** (Free)
   - Nginx or Caddy
   - Let's Encrypt SSL (automatic)

3. **Secure Tunnel** (Free)
   - WireGuard or Tailscale VPN
   - Connects VPS to local n8n

4. **Architecture:**
   ```
   Internet ‚Üí VPS (Nginx + SSL) ‚Üí WireGuard VPN ‚Üí Local n8n

   Benefits:
   - Full control
   - No third-party dependency
   - Better performance
   - Static IP
   - Professional setup
   ```

**See `future_update.md` for detailed migration guide.**

---

## Monitoring Setup

### Tunnel Health Check Workflow

**Create:** `workflows/ngrok_health_monitor.json`

**Schedule:** Every 5 minutes

```javascript
// n8n Function node
const ngrokApiUrl = 'http://localhost:4040/api/tunnels';

// Query ngrok agent API
const response = await fetch(ngrokApiUrl);
const data = await response.json();

if (data.tunnels.length === 0) {
  // Tunnel is down - send alert
  return {
    json: {
      status: 'down',
      alert: true,
      message: 'Ngrok tunnel is not active!'
    }
  };
}

const tunnel = data.tunnels[0];
return {
  json: {
    status: 'up',
    public_url: tunnel.public_url,
    connections: tunnel.metrics.conns.count
  }
};
```

### Metrics to Track

1. **Tunnel uptime** (percentage)
2. **Callback success rate** (received vs expected)
3. **Security events** (failed token validations)
4. **Connection count** (monitor limits)
5. **Response time** (latency)

### Alerting

**Send alerts to Slack/Discord when:**
- Tunnel goes down
- Security validation failures spike
- Connection limit approaching
- Unexpected callback sources

---

## Quick Reference

### Environment Variables
```env
N8N_TUNNEL_ENABLED=true
N8N_TUNNEL_NGROK_AUTH_TOKEN=<your_token>
NGROK_CALLBACK_SECRET=<random_secret>
N8N_TUNNEL_NGROK_SUBDOMAIN=<optional_static>  # Paid tier only
```

### Important URLs
- **Ngrok Dashboard:** https://dashboard.ngrok.com
- **Ngrok API (local):** http://localhost:4040/api/tunnels
- **n8n GUI:** http://localhost:5678
- **Webhook base:** https://YOUR-ID.ngrok.io/webhook/

### Useful Commands
```bash
# Restart with ngrok
docker compose restart n8n-recon

# Check tunnel status
curl http://localhost:4040/api/tunnels | jq

# View logs
docker compose logs n8n-recon | grep -i tunnel

# Disable tunnel
# Set N8N_TUNNEL_ENABLED=false in .env, then restart
```

### Security Checklist
- [ ] NGROK_CALLBACK_SECRET set to random strong value
- [ ] Token validation implemented in all webhook receivers
- [ ] Input sanitization functions created
- [ ] Rate limiting configured
- [ ] Basic auth remains active
- [ ] Monitoring and alerting configured
- [ ] Only expose webhook paths, not full UI
- [ ] Regular security audits scheduled

---

## Next Steps

After completing this setup:

1. ‚úÖ Create webhook callback receiver workflow
2. ‚úÖ Create ngrok manager workflow (optional, for on-demand)
3. ‚úÖ Integrate with Phase 3 (nuclei OAST)
4. ‚úÖ Test OAST detection on practice targets
5. ‚úÖ Set up monitoring and alerts
6. ‚úÖ Review security configuration

**See also:**
- `NGROK_SECURITY.md` - Detailed security guide
- `WORKFLOW_SUMMARY.md` - Workflow architecture
- `future_update.md` - Production migration path

---

**Setup complete!** You now have ngrok tunneling enabled for OAST detection and external webhook callbacks.

**Happy bug hunting! üéØ**
