{
  "name": "Pentest Router",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "pentest",
        "responseMode": "responseNode",
        "options": {}
      },
      "name": "Pentest Input",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [200, 300],
      "webhookId": "pentest-router"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "v2-check",
              "leftValue": "={{ $json.body.version || ($json.body.mode ? 'v2' : ($json.body.target && ($json.body.target.includes('/') || $json.body.target.includes(',') || $json.body.target.includes('*')) ? 'v2' : 'v1')) }}",
              "rightValue": "v2",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ]
        },
        "options": {}
      },
      "name": "Route to Version",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [420, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://ollama:11434/api/generate",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ model: 'llama3.2', prompt: `You are a penetration testing automation assistant.\n\nUser input: \"${$json.body.target}\"\n\nDetermine what the target is:\n- IPv4 address?\n- Domain?\n- URL?\n- Company name?\n\nDecide which recon tools to run. Output a JSON plan ONLY.\nTools available:\n- subfinder -d <domain> -silent\n- amass enum -passive -d <domain>\n- nmap -sV -Pn -T4 --top-ports 100 <target>\n- nuclei -u <url> -severity medium,high,critical -silent\n- httpx -u <target> -silent -status-code -title -tech-detect\n- whois <domain>\n- dig ANY <domain>\n\nReturn JSON with the structure:\n{\n  \"target_type\": \"domain|ip|url|company\",\n  \"sanitized_target\": \"the actual target to scan\",\n  \"commands\": [\n    \"command 1\",\n    \"command 2\"\n  ]\n}\nNo commentary. No explanation. JSON only.`, stream: false }) }}",
        "options": {
          "timeout": 120000
        }
      },
      "name": "AI Planner v1",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [640, 200]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://ollama:11434/api/generate",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ model: 'llama3.2', prompt: `You are a penetration testing automation assistant.\n\nUser input: \"${$json.body.target}\"\nScan mode: \"${$json.body.mode || 'standard'}\"\nOptions: ${JSON.stringify($json.body.options || {})}\n\nDetermine what the target is:\n- IPv4 address (single)?\n- CIDR range (e.g., 192.168.1.0/24)?\n- IP range (e.g., 192.168.1.1-50)?\n- Domain?\n- Wildcard domain (e.g., *.example.com)?\n- URL?\n- Company name?\n- List of targets (comma-separated)?\n\nScan modes:\n- quick: Fast scan, minimal tools (1-2 commands)\n- standard: Balanced scan (3-4 commands)\n- thorough: Comprehensive scan, all tools (5+ commands)\n- stealth: Slow, evasive scanning\n\nDecide which recon tools to run based on target type and scan mode. Output a JSON plan ONLY.\n\nTools available:\n- subfinder -d <domain> -silent\n- amass enum -passive -d <domain>\n- nmap -sV -Pn -T4 --top-ports 100 <target>\n- nmap -sn <cidr> (ping sweep for network ranges)\n- nmap -p- -T4 <target> (full port scan)\n- nuclei -u <url> -severity medium,high,critical -silent\n- httpx -u <target> -silent -status-code -title -tech-detect\n- whois <domain>\n- dig ANY <domain>\n\nFor CIDR/ranges:\n1. First do host discovery (nmap -sn)\n2. Then scan discovered hosts\n\nFor multiple targets, create commands that handle them efficiently.\n\nReturn JSON with the structure:\n{\n  \"target_type\": \"domain|ip|cidr|range|url|company|wildcard|multiple\",\n  \"sanitized_target\": \"the actual target(s) to scan\",\n  \"scan_mode\": \"quick|standard|thorough|stealth\",\n  \"estimated_duration\": \"short|medium|long\",\n  \"commands\": [\n    \"command 1\",\n    \"command 2\"\n  ],\n  \"notes\": \"any relevant notes about the scan plan\"\n}\nNo commentary. No explanation. JSON only.`, stream: false }) }}",
        "options": {
          "timeout": 120000
        }
      },
      "name": "AI Planner v2",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [640, 400]
    },
    {
      "parameters": {
        "jsCode": "// Extract JSON from Ollama response\nconst response = $input.first().json.response;\n\nlet jsonStr = response;\nconst jsonMatch = response.match(/\\{[\\s\\S]*\\}/);\nif (jsonMatch) {\n  jsonStr = jsonMatch[0];\n}\n\ntry {\n  const plan = JSON.parse(jsonStr);\n  \n  const items = plan.commands.map((cmd, index) => ({\n    json: {\n      command: cmd,\n      index: index,\n      target_type: plan.target_type,\n      sanitized_target: plan.sanitized_target,\n      total_commands: plan.commands.length,\n      version: 'v1'\n    }\n  }));\n  \n  return items;\n} catch (e) {\n  throw new Error(`Failed to parse AI response: ${e.message}\\nResponse was: ${response}`);\n}"
      },
      "name": "Parse Plan v1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [860, 200]
    },
    {
      "parameters": {
        "jsCode": "// Extract JSON from Ollama response\nconst response = $input.first().json.response;\n\nlet jsonStr = response;\nconst jsonMatch = response.match(/\\{[\\s\\S]*\\}/);\nif (jsonMatch) {\n  jsonStr = jsonMatch[0];\n}\n\ntry {\n  const plan = JSON.parse(jsonStr);\n  \n  const items = plan.commands.map((cmd, index) => ({\n    json: {\n      command: cmd,\n      index: index,\n      target_type: plan.target_type,\n      sanitized_target: plan.sanitized_target,\n      scan_mode: plan.scan_mode || 'standard',\n      estimated_duration: plan.estimated_duration || 'medium',\n      notes: plan.notes || '',\n      total_commands: plan.commands.length,\n      version: 'v2'\n    }\n  }));\n  \n  return items;\n} catch (e) {\n  throw new Error(`Failed to parse AI response: ${e.message}\\nResponse was: ${response}`);\n}"
      },
      "name": "Parse Plan v2",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [860, 400]
    },
    {
      "parameters": {
        "mode": "append",
        "options": {}
      },
      "name": "Merge",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [1080, 300]
    },
    {
      "parameters": {
        "batchSize": 1,
        "options": {}
      },
      "name": "Loop Commands",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [1300, 300]
    },
    {
      "parameters": {
        "command": "={{ (() => { const cmd = $json.command; const tool = cmd.split(' ')[0]; return `which ${tool} > /dev/null 2>&1 || install-tool ${tool} > /dev/null 2>&1; ${cmd}`; })() }}",
        "options": {
          "timeout": 300000
        }
      },
      "name": "Run Command",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [1520, 300]
    },
    {
      "parameters": {
        "jsCode": "const allItems = $input.all();\nconst results = allItems.map(item => ({\n  command: item.json.command,\n  stdout: item.json.stdout || '',\n  stderr: item.json.stderr || '',\n  exitCode: item.json.exitCode\n}));\n\nreturn [{\n  json: {\n    results: results,\n    target_type: allItems[0]?.json.target_type || 'unknown',\n    sanitized_target: allItems[0]?.json.sanitized_target || 'unknown',\n    scan_mode: allItems[0]?.json.scan_mode || 'standard',\n    estimated_duration: allItems[0]?.json.estimated_duration || 'medium',\n    notes: allItems[0]?.json.notes || '',\n    version: allItems[0]?.json.version || 'v1'\n  }\n}];"
      },
      "name": "Aggregate Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1740, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://ollama:11434/api/generate",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ model: 'llama3.2', prompt: `You are a senior penetration tester writing a security assessment report.\n\nTarget: ${$json.sanitized_target} (${$json.target_type})\nScan Mode: ${$json.scan_mode}\nVersion: ${$json.version}\n\nHere are the reconnaissance results from multiple tools:\n\n${$json.results.map(r => `### Command: ${r.command}\\nExit Code: ${r.exitCode}\\n\\nOutput:\\n${r.stdout.substring(0, 3000)}\\n${r.stderr ? 'Errors: ' + r.stderr.substring(0, 500) : ''}`).join('\\n\\n---\\n\\n')}\n\nWrite a concise offensive security report including:\n\n1. **Executive Summary** - Brief overview of findings\n2. **Target Classification** - What type of target and scope\n3. **Discovered Assets** - Subdomains, IPs, services found\n4. **Open Ports & Services** - What's exposed\n5. **Vulnerabilities Found** - Any issues from Nuclei or other tools\n6. **Risk Assessment** - High/Medium/Low findings\n7. **Recommended Next Steps** - What to investigate further\n\nOutput in clean Markdown format.`, stream: false }) }}",
        "options": {
          "timeout": 180000
        }
      },
      "name": "AI Generate Report",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1960, 300]
    },
    {
      "parameters": {
        "jsCode": "const report = $input.first().json.response;\nconst agg = $('Aggregate Results').first().json;\n\nreturn [{\n  json: {\n    success: true,\n    report: report,\n    target: agg.sanitized_target,\n    target_type: agg.target_type,\n    scan_mode: agg.scan_mode,\n    version: agg.version,\n    commands_executed: agg.results.length,\n    notes: agg.notes,\n    timestamp: new Date().toISOString()\n  }\n}];"
      },
      "name": "Format Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2180, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {}
      },
      "name": "Return Report",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [2400, 300]
    }
  ],
  "connections": {
    "Pentest Input": {
      "main": [
        [
          {
            "node": "Route to Version",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route to Version": {
      "main": [
        [
          {
            "node": "AI Planner v2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "AI Planner v1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Planner v1": {
      "main": [
        [
          {
            "node": "Parse Plan v1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Planner v2": {
      "main": [
        [
          {
            "node": "Parse Plan v2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Plan v1": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Plan v2": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Loop Commands",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Commands": {
      "main": [
        [
          {
            "node": "Run Command",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Aggregate Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run Command": {
      "main": [
        [
          {
            "node": "Loop Commands",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate Results": {
      "main": [
        [
          {
            "node": "AI Generate Report",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Generate Report": {
      "main": [
        [
          {
            "node": "Format Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Response": {
      "main": [
        [
          {
            "node": "Return Report",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": ""
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 0,
  "updatedAt": "2025-01-01T00:00:00.000Z",
  "versionId": "1"
}
