{
  "name": "Pentest Router v2",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "pentest/v2",
        "responseMode": "responseNode",
        "options": {}
      },
      "name": "Webhook Input",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [200, 300],
      "webhookId": "pentest-router-v2"
    },
    {
      "parameters": {
        "jsCode": "// Validate input and extract parameters\nconst body = $input.first().json.body;\n\n// Required: project_id\nif (!body.project_id) {\n  throw new Error('project_id is required');\n}\n\n// Required: target\nif (!body.target) {\n  throw new Error('target is required');\n}\n\nreturn [{\n  json: {\n    project_id: body.project_id,\n    target: body.target,\n    mode: body.mode || 'standard',\n    options: body.options || {},\n    request_id: require('crypto').randomUUID(),\n    timestamp: new Date().toISOString()\n  }\n}];"
      },
      "name": "Validate Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [420, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT id, name, scope, roe, settings, status FROM projects WHERE id = '{{ $json.project_id }}'::uuid",
        "options": {}
      },
      "name": "Get Project",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [640, 300],
      "credentials": {
        "postgres": {
          "id": "1",
          "name": "Postgres"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Validate project exists and check scope\nconst input = $('Validate Input').first().json;\nconst projectResult = $input.first().json;\n\nif (!projectResult || !projectResult.id) {\n  throw new Error(`Project not found: ${input.project_id}`);\n}\n\nif (projectResult.status !== 'active') {\n  throw new Error(`Project is not active: ${projectResult.status}`);\n}\n\nconst settings = projectResult.settings || {};\nconst scope = projectResult.scope || [];\n\n// Check if target is in scope (if scope is defined)\nlet inScope = true;\nif (scope.length > 0) {\n  inScope = scope.some(s => {\n    if (s.includes('*')) {\n      const pattern = s.replace(/\\*/g, '.*');\n      return new RegExp(pattern).test(input.target);\n    }\n    return input.target.includes(s) || s.includes(input.target);\n  });\n}\n\nif (!inScope) {\n  throw new Error(`Target not in project scope: ${input.target}`);\n}\n\nreturn [{\n  json: {\n    ...input,\n    project_name: projectResult.name,\n    settings: settings,\n    roe: projectResult.roe || {},\n    max_concurrent: settings.max_concurrent_scans || 3,\n    target_cooldown: settings.target_cooldown_minutes || 5\n  }\n}];"
      },
      "name": "Check Project & Scope",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [860, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Check rate limits and concurrent scans\nWITH concurrent AS (\n  SELECT COUNT(*) as running\n  FROM scan_jobs\n  WHERE project_id = '{{ $json.project_id }}'::uuid\n  AND status = 'running'\n),\ntarget_limit AS (\n  SELECT cooldown_until\n  FROM rate_limits\n  WHERE project_id = '{{ $json.project_id }}'::uuid\n  AND target = '{{ $json.target }}'\n  AND limit_type = 'scan'\n  AND cooldown_until > NOW()\n)\nSELECT\n  (SELECT running FROM concurrent) as concurrent_scans,\n  (SELECT cooldown_until FROM target_limit) as cooldown_until",
        "options": {}
      },
      "name": "Check Rate Limits",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [1080, 300],
      "credentials": {
        "postgres": {
          "id": "1",
          "name": "Postgres"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Enforce rate limits\nconst input = $('Check Project & Scope').first().json;\nconst limits = $input.first().json;\n\nconst concurrentScans = parseInt(limits.concurrent_scans) || 0;\nconst maxConcurrent = input.max_concurrent;\n\nif (concurrentScans >= maxConcurrent) {\n  throw new Error(`Rate limit exceeded: ${concurrentScans}/${maxConcurrent} concurrent scans running`);\n}\n\nif (limits.cooldown_until) {\n  const cooldownTime = new Date(limits.cooldown_until);\n  const now = new Date();\n  if (cooldownTime > now) {\n    const waitSeconds = Math.ceil((cooldownTime - now) / 1000);\n    throw new Error(`Target in cooldown: wait ${waitSeconds} seconds`);\n  }\n}\n\nreturn [{ json: input }];"
      },
      "name": "Enforce Limits",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1300, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO scan_jobs (project_id, job_type, status, target, target_type, scan_mode, metadata)\nVALUES (\n  '{{ $json.project_id }}'::uuid,\n  'pentest',\n  'running',\n  '{{ $json.target }}',\n  NULL,\n  '{{ $json.mode }}',\n  '{{ JSON.stringify({ request_id: $json.request_id, options: $json.options }) }}'\n)\nRETURNING id, created_at",
        "options": {}
      },
      "name": "Create Scan Job",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [1520, 300],
      "credentials": {
        "postgres": {
          "id": "1",
          "name": "Postgres"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Merge scan job ID with input\nconst input = $('Enforce Limits').first().json;\nconst scanJob = $input.first().json;\n\nreturn [{\n  json: {\n    ...input,\n    scan_job_id: scanJob.id,\n    job_created_at: scanJob.created_at\n  }\n}];"
      },
      "name": "Merge Job ID",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1740, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://ollama:11434/api/generate",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ model: 'llama3.2', prompt: `You are an advanced penetration testing automation assistant.\n\nUser request: \"${$json.target}\"\nScan mode: \"${$json.mode}\"\nOptions: ${JSON.stringify($json.options)}\n\nExtract the actual target from the user's request and determine target type:\n- IPv4/CIDR/IP range\n- Domain/Wildcard domain\n- URL/Web application\n- Multiple targets (comma-separated)\n\nScan modes:\n- quick: Fast scan (1-2 commands)\n- standard: Balanced scan (3-5 commands)\n- thorough: Comprehensive scan (6+ commands)\n- stealth: Slow, evasive (-T2, -sS flags)\n\nTOOLS AVAILABLE:\nPORT SCANNING: nmap -F -T4, nmap -sV -sC -p-, nmap -sS -Pn -T2, nmap -sU --top-ports 50\nSUBDOMAIN/DNS: subfinder -d, amass enum -passive -d, dnsrecon -d, dig ANY\nWEB RECON: httpx -u, nuclei -u -severity medium,high,critical, gobuster dir -u, whatweb -a 3\nOSINT: whois, theHarvester -d -b all, waybackurls\n\nReturn JSON only:\n{\n  \"target_type\": \"domain|ip|cidr|url|multiple\",\n  \"sanitized_target\": \"actual target(s)\",\n  \"scan_mode\": \"quick|standard|thorough|stealth\",\n  \"estimated_duration\": \"short|medium|long\",\n  \"commands\": [\"cmd1\", \"cmd2\"],\n  \"notes\": \"brief scan notes\"\n}`, stream: false }) }}",
        "options": {
          "timeout": 120000
        }
      },
      "name": "AI Planner",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1960, 300]
    },
    {
      "parameters": {
        "jsCode": "// Parse AI response and prepare commands\nconst input = $('Merge Job ID').first().json;\nconst response = $input.first().json.response;\n\nlet jsonStr = response;\nconst jsonMatch = response.match(/\\{[\\s\\S]*\\}/);\nif (jsonMatch) {\n  jsonStr = jsonMatch[0];\n}\n\ntry {\n  const plan = JSON.parse(jsonStr);\n  \n  // Limit commands based on settings\n  const maxCommands = 20;\n  const commands = plan.commands.slice(0, maxCommands);\n  \n  const items = commands.map((cmd, index) => ({\n    json: {\n      command: cmd,\n      index: index,\n      scan_job_id: input.scan_job_id,\n      project_id: input.project_id,\n      target_type: plan.target_type,\n      sanitized_target: plan.sanitized_target,\n      scan_mode: plan.scan_mode || input.mode,\n      estimated_duration: plan.estimated_duration || 'medium',\n      notes: plan.notes || '',\n      total_commands: commands.length\n    }\n  }));\n  \n  return items;\n} catch (e) {\n  throw new Error(`Failed to parse AI response: ${e.message}`);\n}"
      },
      "name": "Parse Plan",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2180, 300]
    },
    {
      "parameters": {
        "batchSize": 1,
        "options": {}
      },
      "name": "Loop Commands",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [2400, 300]
    },
    {
      "parameters": {
        "command": "={{ (() => { const cmd = $json.command; const tool = cmd.split(' ')[0]; return `which ${tool} > /dev/null 2>&1 || install-tool ${tool} > /dev/null 2>&1; ${cmd}`; })() }}",
        "options": {
          "timeout": 300000
        }
      },
      "name": "Execute Command",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [2620, 300]
    },
    {
      "parameters": {
        "jsCode": "// Aggregate all command results\nconst allItems = $input.all();\nconst firstItem = allItems[0]?.json || {};\n\nconst results = allItems.map(item => ({\n  command: item.json.command,\n  stdout: item.json.stdout || '',\n  stderr: item.json.stderr || '',\n  exitCode: item.json.exitCode,\n  index: item.json.index\n}));\n\n// Calculate raw output size\nconst totalOutput = results.reduce((acc, r) => acc + (r.stdout?.length || 0) + (r.stderr?.length || 0), 0);\n\nreturn [{\n  json: {\n    scan_job_id: firstItem.scan_job_id,\n    project_id: firstItem.project_id,\n    results: results,\n    target_type: firstItem.target_type,\n    sanitized_target: firstItem.sanitized_target,\n    scan_mode: firstItem.scan_mode,\n    estimated_duration: firstItem.estimated_duration,\n    notes: firstItem.notes,\n    total_commands: results.length,\n    total_output_bytes: totalOutput,\n    timestamp: new Date().toISOString()\n  }\n}];"
      },
      "name": "Aggregate Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2840, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://ollama:11434/api/generate",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ model: 'llama3.2', prompt: `You are a senior penetration tester writing a security assessment report.\n\nTarget: ${$json.sanitized_target} (${$json.target_type})\nScan Mode: ${$json.scan_mode}\n\nReconnaissance results:\n\n${$json.results.map(r => `### Command: ${r.command}\\nExit Code: ${r.exitCode}\\n\\nOutput:\\n${r.stdout.substring(0, 3000)}\\n${r.stderr ? 'Errors: ' + r.stderr.substring(0, 500) : ''}`).join('\\n\\n---\\n\\n')}\n\nWrite a concise offensive security report:\n\n1. **Executive Summary** - Brief overview\n2. **Target Classification** - Type and scope\n3. **Discovered Assets** - Subdomains, IPs, services\n4. **Open Ports & Services** - What's exposed\n5. **Vulnerabilities Found** - Issues from tools\n6. **Risk Assessment** - High/Medium/Low\n7. **Recommended Next Steps** - Further investigation\n\nOutput in clean Markdown.`, stream: false }) }}",
        "options": {
          "timeout": 180000
        }
      },
      "name": "AI Generate Report",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [3060, 300]
    },
    {
      "parameters": {
        "jsCode": "// Prepare final results for storage\nconst agg = $('Aggregate Results').first().json;\nconst report = $input.first().json.response;\n\nreturn [{\n  json: {\n    scan_job_id: agg.scan_job_id,\n    project_id: agg.project_id,\n    report: report,\n    results: agg.results,\n    target: agg.sanitized_target,\n    target_type: agg.target_type,\n    scan_mode: agg.scan_mode,\n    commands_executed: agg.total_commands,\n    total_output_bytes: agg.total_output_bytes,\n    notes: agg.notes,\n    timestamp: agg.timestamp\n  }\n}];"
      },
      "name": "Prepare Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3280, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Update scan job with results\nUPDATE scan_jobs\nSET\n  status = 'completed',\n  target_type = '{{ $json.target_type }}',\n  commands = '{{ JSON.stringify($json.results.map(r => r.command)) }}'::jsonb,\n  results = '{{ JSON.stringify($json.results) }}'::jsonb,\n  report = '{{ $json.report.replace(/'/g, \"''\") }}',\n  completed_at = NOW(),\n  metadata = metadata || '{{ JSON.stringify({ commands_executed: $json.commands_executed, total_output_bytes: $json.total_output_bytes }) }}'::jsonb\nWHERE id = '{{ $json.scan_job_id }}'::uuid\nRETURNING id, status, completed_at",
        "options": {}
      },
      "name": "Save Results",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [3500, 300],
      "credentials": {
        "postgres": {
          "id": "1",
          "name": "Postgres"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Update rate limits for target\nINSERT INTO rate_limits (project_id, target, limit_type, last_action, cooldown_until)\nVALUES (\n  '{{ $json.project_id }}'::uuid,\n  '{{ $json.target }}',\n  'scan',\n  NOW(),\n  NOW() + INTERVAL '5 minutes'\n)\nON CONFLICT (project_id, target, limit_type)\nDO UPDATE SET\n  last_action = NOW(),\n  action_count = rate_limits.action_count + 1,\n  cooldown_until = NOW() + INTERVAL '5 minutes'",
        "options": {}
      },
      "name": "Update Rate Limits",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [3720, 300],
      "credentials": {
        "postgres": {
          "id": "1",
          "name": "Postgres"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Log audit trail\nINSERT INTO audit_log (project_id, action, entity_type, entity_id, details)\nVALUES (\n  '{{ $json.project_id }}'::uuid,\n  'scan_completed',\n  'scan_job',\n  '{{ $json.scan_job_id }}'::uuid,\n  '{{ JSON.stringify({ target: $json.target, target_type: $json.target_type, commands_executed: $json.commands_executed }) }}'\n)",
        "options": {}
      },
      "name": "Audit Log",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [3940, 300],
      "credentials": {
        "postgres": {
          "id": "1",
          "name": "Postgres"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Format final response\nconst results = $('Prepare Results').first().json;\nconst saved = $('Save Results').first().json;\n\nreturn [{\n  json: {\n    success: true,\n    scan_job_id: results.scan_job_id,\n    project_id: results.project_id,\n    target: results.target,\n    target_type: results.target_type,\n    scan_mode: results.scan_mode,\n    status: 'completed',\n    commands_executed: results.commands_executed,\n    report: results.report,\n    completed_at: saved.completed_at,\n    message: 'Scan completed successfully. Results stored in database.'\n  }\n}];"
      },
      "name": "Format Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [4160, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {}
      },
      "name": "Return Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [4380, 300]
    },
    {
      "parameters": {
        "jsCode": "// Error handler - update scan job status\nconst error = $input.first().json;\nlet scanJobId = null;\n\n// Try to get scan_job_id from context\ntry {\n  scanJobId = $('Merge Job ID').first().json.scan_job_id;\n} catch (e) {\n  // Job wasn't created yet\n}\n\nreturn [{\n  json: {\n    error: true,\n    scan_job_id: scanJobId,\n    message: error.message || 'Unknown error',\n    timestamp: new Date().toISOString()\n  }\n}];"
      },
      "name": "Error Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3060, 500]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "has-job-id",
              "leftValue": "={{ $json.scan_job_id }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              }
            }
          ]
        },
        "options": {}
      },
      "name": "Has Job ID?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [3280, 500]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE scan_jobs SET status = 'failed', error_message = '{{ $json.message.replace(/'/g, \"''\") }}', completed_at = NOW() WHERE id = '{{ $json.scan_job_id }}'::uuid",
        "options": {}
      },
      "name": "Mark Job Failed",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [3500, 450],
      "credentials": {
        "postgres": {
          "id": "1",
          "name": "Postgres"
        }
      }
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ success: false, error: $json.message, scan_job_id: $json.scan_job_id }) }}",
        "options": {
          "responseCode": 400
        }
      },
      "name": "Return Error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [3720, 500]
    }
  ],
  "connections": {
    "Webhook Input": {
      "main": [
        [
          {
            "node": "Validate Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Input": {
      "main": [
        [
          {
            "node": "Get Project",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Project": {
      "main": [
        [
          {
            "node": "Check Project & Scope",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Project & Scope": {
      "main": [
        [
          {
            "node": "Check Rate Limits",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Rate Limits": {
      "main": [
        [
          {
            "node": "Enforce Limits",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Enforce Limits": {
      "main": [
        [
          {
            "node": "Create Scan Job",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Scan Job": {
      "main": [
        [
          {
            "node": "Merge Job ID",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Job ID": {
      "main": [
        [
          {
            "node": "AI Planner",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Planner": {
      "main": [
        [
          {
            "node": "Parse Plan",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Plan": {
      "main": [
        [
          {
            "node": "Loop Commands",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Commands": {
      "main": [
        [
          {
            "node": "Execute Command",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Aggregate Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute Command": {
      "main": [
        [
          {
            "node": "Loop Commands",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate Results": {
      "main": [
        [
          {
            "node": "AI Generate Report",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Generate Report": {
      "main": [
        [
          {
            "node": "Prepare Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Results": {
      "main": [
        [
          {
            "node": "Save Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save Results": {
      "main": [
        [
          {
            "node": "Update Rate Limits",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Rate Limits": {
      "main": [
        [
          {
            "node": "Audit Log",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Audit Log": {
      "main": [
        [
          {
            "node": "Format Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Response": {
      "main": [
        [
          {
            "node": "Return Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Error Handler": {
      "main": [
        [
          {
            "node": "Has Job ID?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Job ID?": {
      "main": [
        [
          {
            "node": "Mark Job Failed",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Return Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mark Job Failed": {
      "main": [
        [
          {
            "node": "Return Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": ""
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 0,
  "updatedAt": "2025-01-01T00:00:00.000Z",
  "versionId": "2"
}
