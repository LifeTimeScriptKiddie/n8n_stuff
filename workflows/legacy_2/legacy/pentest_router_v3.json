{
  "name": "Pentest Router v3 (Pivot)",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "pentest/v3",
        "responseMode": "responseNode",
        "options": {}
      },
      "name": "Webhook Input",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [200, 300],
      "webhookId": "pentest-router-v3"
    },
    {
      "parameters": {
        "jsCode": "// Validate input - v3 supports tunnel_id for proxied scans\nconst body = $input.first().json.body;\n\nif (!body.project_id) {\n  throw new Error('project_id is required');\n}\n\nif (!body.target) {\n  throw new Error('target is required');\n}\n\nreturn [{\n  json: {\n    project_id: body.project_id,\n    target: body.target,\n    mode: body.mode || 'standard',\n    options: body.options || {},\n    tunnel_id: body.tunnel_id || null,  // Optional: route through tunnel\n    proxychains_config: body.proxychains_config || null,\n    request_id: require('crypto').randomUUID(),\n    timestamp: new Date().toISOString()\n  }\n}];"
      },
      "name": "Validate Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [420, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT id, name, scope, roe, settings, status FROM projects WHERE id = '{{ $json.project_id }}'::uuid",
        "options": {}
      },
      "name": "Get Project",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [640, 300],
      "credentials": {
        "postgres": {
          "id": "1",
          "name": "Postgres"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Validate project and check tunnel if specified\nconst input = $('Validate Input').first().json;\nconst projectResult = $input.first().json;\n\nif (!projectResult || !projectResult.id) {\n  throw new Error(`Project not found: ${input.project_id}`);\n}\n\nif (projectResult.status !== 'active') {\n  throw new Error(`Project is not active: ${projectResult.status}`);\n}\n\nconst settings = projectResult.settings || {};\n\nreturn [{\n  json: {\n    ...input,\n    project_name: projectResult.name,\n    settings: settings,\n    max_concurrent: settings.max_concurrent_scans || 3,\n    target_cooldown: settings.target_cooldown_minutes || 5\n  }\n}];"
      },
      "name": "Check Project",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [860, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "has-tunnel",
              "leftValue": "={{ $json.tunnel_id }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              }
            }
          ]
        },
        "options": {}
      },
      "name": "Has Tunnel?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1080, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Get tunnel info and verify it's active\nSELECT\n  t.id,\n  t.local_port,\n  t.status,\n  t.hop_level,\n  generate_proxychains_config(ARRAY[t.id]) as proxychains_config\nFROM ssh_tunnels t\nWHERE t.id = '{{ $json.tunnel_id }}'::uuid\nAND t.status = 'active'",
        "options": {}
      },
      "name": "Get Tunnel",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [1300, 200],
      "credentials": {
        "postgres": {
          "id": "1",
          "name": "Postgres"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Merge tunnel info with input\nconst input = $('Check Project').first().json;\nconst tunnel = $input.first().json;\n\nif (!tunnel || !tunnel.id) {\n  throw new Error(`Tunnel not found or not active: ${input.tunnel_id}`);\n}\n\n// Write proxychains config to temp file\nconst configPath = `/tmp/proxy_${tunnel.id}.conf`;\n\nreturn [{\n  json: {\n    ...input,\n    tunnel_port: tunnel.local_port,\n    tunnel_hop: tunnel.hop_level,\n    proxychains_config: tunnel.proxychains_config,\n    config_path: configPath,\n    use_proxy: true\n  }\n}];"
      },
      "name": "Merge Tunnel",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1520, 200]
    },
    {
      "parameters": {
        "command": "=echo '{{ $json.proxychains_config }}' > {{ $json.config_path }}",
        "options": {}
      },
      "name": "Write Proxy Config",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [1740, 200]
    },
    {
      "parameters": {
        "jsCode": "// No tunnel - direct scan\nconst input = $('Check Project').first().json;\n\nreturn [{\n  json: {\n    ...input,\n    use_proxy: false,\n    config_path: null\n  }\n}];"
      },
      "name": "Direct Scan",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1300, 400]
    },
    {
      "parameters": {
        "mode": "append",
        "options": {}
      },
      "name": "Merge Paths",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [1960, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO scan_jobs (project_id, job_type, status, target, target_type, scan_mode, metadata)\nVALUES (\n  '{{ $json.project_id }}'::uuid,\n  '{{ $json.use_proxy ? \"proxied_pentest\" : \"pentest\" }}',\n  'running',\n  '{{ $json.target }}',\n  NULL,\n  '{{ $json.mode }}',\n  '{{ JSON.stringify({ request_id: $json.request_id, tunnel_id: $json.tunnel_id, use_proxy: $json.use_proxy, hop_level: $json.tunnel_hop }) }}'\n)\nRETURNING id, created_at",
        "options": {}
      },
      "name": "Create Scan Job",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [2180, 300],
      "credentials": {
        "postgres": {
          "id": "1",
          "name": "Postgres"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Merge scan job ID\nconst input = $('Merge Paths').first().json;\nconst scanJob = $input.first().json;\n\nreturn [{\n  json: {\n    ...input,\n    scan_job_id: scanJob.id,\n    job_created_at: scanJob.created_at\n  }\n}];"
      },
      "name": "Merge Job ID",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2400, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://ollama:11434/api/generate",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ model: 'llama3.2', prompt: `You are an advanced penetration testing assistant. ${$json.use_proxy ? 'Commands will be routed through a SOCKS proxy for internal network access.' : ''}\n\nUser request: \"${$json.target}\"\nScan mode: \"${$json.mode}\"\n${$json.use_proxy ? 'Proxy: SOCKS5 on port ' + $json.tunnel_port : 'Direct scan'}\n\nExtract target and determine type. Select appropriate tools.\n\nTOOLS:\n- nmap -sV -sC -p- <target>\n- nmap -sn <cidr> (host discovery)\n- httpx -u <target> -silent -status-code -title -tech-detect\n- nuclei -u <url> -severity medium,high,critical\n- gobuster dir -u <url> -w /opt/SecLists/Discovery/Web-Content/common.txt\n- dig ANY <domain>\n- whois <domain>\n\nReturn JSON:\n{\n  \"target_type\": \"domain|ip|cidr|url\",\n  \"sanitized_target\": \"target\",\n  \"scan_mode\": \"${$json.mode}\",\n  \"commands\": [\"cmd1\", \"cmd2\"]\n}`, stream: false }) }}",
        "options": {
          "timeout": 120000
        }
      },
      "name": "AI Planner",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2620, 300]
    },
    {
      "parameters": {
        "jsCode": "// Parse AI response and add proxy prefix if needed\nconst input = $('Merge Job ID').first().json;\nconst response = $input.first().json.response;\n\nlet jsonStr = response;\nconst jsonMatch = response.match(/\\{[\\s\\S]*\\}/);\nif (jsonMatch) {\n  jsonStr = jsonMatch[0];\n}\n\ntry {\n  const plan = JSON.parse(jsonStr);\n  const maxCommands = 20;\n  let commands = plan.commands.slice(0, maxCommands);\n\n  // Add proxychains prefix if using tunnel\n  if (input.use_proxy && input.config_path) {\n    commands = commands.map(cmd => {\n      // Don't proxy local commands\n      if (cmd.startsWith('echo') || cmd.startsWith('cat')) {\n        return cmd;\n      }\n      return `proxychains -f ${input.config_path} ${cmd}`;\n    });\n  }\n\n  const items = commands.map((cmd, index) => ({\n    json: {\n      command: cmd,\n      index: index,\n      scan_job_id: input.scan_job_id,\n      project_id: input.project_id,\n      target_type: plan.target_type,\n      sanitized_target: plan.sanitized_target,\n      scan_mode: plan.scan_mode || input.mode,\n      total_commands: commands.length,\n      use_proxy: input.use_proxy,\n      tunnel_id: input.tunnel_id\n    }\n  }));\n\n  return items;\n} catch (e) {\n  throw new Error(`Failed to parse AI response: ${e.message}`);\n}"
      },
      "name": "Parse Plan",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2840, 300]
    },
    {
      "parameters": {
        "batchSize": 1,
        "options": {}
      },
      "name": "Loop Commands",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [3060, 300]
    },
    {
      "parameters": {
        "command": "={{ $json.command }}",
        "options": {
          "timeout": 300000
        }
      },
      "name": "Execute Command",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [3280, 300]
    },
    {
      "parameters": {
        "jsCode": "// Aggregate results\nconst allItems = $input.all();\nconst firstItem = allItems[0]?.json || {};\n\nconst results = allItems.map(item => ({\n  command: item.json.command,\n  stdout: item.json.stdout || '',\n  stderr: item.json.stderr || '',\n  exitCode: item.json.exitCode,\n  index: item.json.index\n}));\n\nreturn [{\n  json: {\n    scan_job_id: firstItem.scan_job_id,\n    project_id: firstItem.project_id,\n    results: results,\n    target_type: firstItem.target_type,\n    sanitized_target: firstItem.sanitized_target,\n    scan_mode: firstItem.scan_mode,\n    total_commands: results.length,\n    use_proxy: firstItem.use_proxy,\n    tunnel_id: firstItem.tunnel_id,\n    timestamp: new Date().toISOString()\n  }\n}];"
      },
      "name": "Aggregate Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3500, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://ollama:11434/api/generate",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ model: 'llama3.2', prompt: `You are a senior penetration tester.\n\nTarget: ${$json.sanitized_target} (${$json.target_type})\nScan Mode: ${$json.scan_mode}\n${$json.use_proxy ? 'Scanned via: Pivot tunnel (internal network)' : 'Direct scan'}\n\nResults:\n\n${$json.results.map(r => `### ${r.command}\\nExit: ${r.exitCode}\\n\\n${r.stdout.substring(0, 3000)}\\n${r.stderr ? 'Errors: ' + r.stderr.substring(0, 500) : ''}`).join('\\n\\n---\\n\\n')}\n\nWrite security report:\n1. Executive Summary\n2. Discovered Assets\n3. Open Ports & Services\n4. Vulnerabilities\n5. Risk Assessment\n6. Next Steps${$json.use_proxy ? '\\n7. Pivot Opportunities - hosts that could be pivoted to next' : ''}\n\nMarkdown format.`, stream: false }) }}",
        "options": {
          "timeout": 180000
        }
      },
      "name": "AI Report",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [3720, 300]
    },
    {
      "parameters": {
        "jsCode": "// Prepare final results\nconst agg = $('Aggregate Results').first().json;\nconst report = $input.first().json.response;\n\nreturn [{\n  json: {\n    scan_job_id: agg.scan_job_id,\n    project_id: agg.project_id,\n    report: report,\n    results: agg.results,\n    target: agg.sanitized_target,\n    target_type: agg.target_type,\n    scan_mode: agg.scan_mode,\n    commands_executed: agg.total_commands,\n    use_proxy: agg.use_proxy,\n    tunnel_id: agg.tunnel_id,\n    timestamp: agg.timestamp\n  }\n}];"
      },
      "name": "Prepare Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3940, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE scan_jobs\nSET status = 'completed',\n    target_type = '{{ $json.target_type }}',\n    commands = '{{ JSON.stringify($json.results.map(r => r.command)) }}'::jsonb,\n    results = '{{ JSON.stringify($json.results) }}'::jsonb,\n    report = '{{ $json.report.replace(/'/g, \"''\") }}',\n    completed_at = NOW()\nWHERE id = '{{ $json.scan_job_id }}'::uuid\nRETURNING id, status, completed_at",
        "options": {}
      },
      "name": "Save Results",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [4160, 300],
      "credentials": {
        "postgres": {
          "id": "1",
          "name": "Postgres"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO audit_log (project_id, action, entity_type, entity_id, details)\nVALUES (\n  '{{ $json.project_id }}'::uuid,\n  'scan_completed',\n  'scan_job',\n  '{{ $json.scan_job_id }}'::uuid,\n  '{{ JSON.stringify({ target: $json.target, use_proxy: $json.use_proxy, tunnel_id: $json.tunnel_id, commands: $json.commands_executed }) }}'\n)",
        "options": {}
      },
      "name": "Audit Log",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [4380, 300],
      "credentials": {
        "postgres": {
          "id": "1",
          "name": "Postgres"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Format response\nconst results = $('Prepare Results').first().json;\nconst saved = $('Save Results').first().json;\n\nreturn [{\n  json: {\n    success: true,\n    scan_job_id: results.scan_job_id,\n    project_id: results.project_id,\n    target: results.target,\n    target_type: results.target_type,\n    scan_mode: results.scan_mode,\n    status: 'completed',\n    commands_executed: results.commands_executed,\n    proxied: results.use_proxy,\n    tunnel_id: results.tunnel_id,\n    report: results.report,\n    completed_at: saved.completed_at,\n    message: results.use_proxy ? 'Proxied scan completed via pivot tunnel' : 'Direct scan completed'\n  }\n}];"
      },
      "name": "Format Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [4600, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {}
      },
      "name": "Return Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [4820, 300]
    }
  ],
  "connections": {
    "Webhook Input": {
      "main": [
        [
          {
            "node": "Validate Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Input": {
      "main": [
        [
          {
            "node": "Get Project",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Project": {
      "main": [
        [
          {
            "node": "Check Project",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Project": {
      "main": [
        [
          {
            "node": "Has Tunnel?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Tunnel?": {
      "main": [
        [
          {
            "node": "Get Tunnel",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Direct Scan",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Tunnel": {
      "main": [
        [
          {
            "node": "Merge Tunnel",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Tunnel": {
      "main": [
        [
          {
            "node": "Write Proxy Config",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Write Proxy Config": {
      "main": [
        [
          {
            "node": "Merge Paths",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Direct Scan": {
      "main": [
        [
          {
            "node": "Merge Paths",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Paths": {
      "main": [
        [
          {
            "node": "Create Scan Job",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Scan Job": {
      "main": [
        [
          {
            "node": "Merge Job ID",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Job ID": {
      "main": [
        [
          {
            "node": "AI Planner",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Planner": {
      "main": [
        [
          {
            "node": "Parse Plan",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Plan": {
      "main": [
        [
          {
            "node": "Loop Commands",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Commands": {
      "main": [
        [
          {
            "node": "Execute Command",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Aggregate Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute Command": {
      "main": [
        [
          {
            "node": "Loop Commands",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate Results": {
      "main": [
        [
          {
            "node": "AI Report",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Report": {
      "main": [
        [
          {
            "node": "Prepare Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Results": {
      "main": [
        [
          {
            "node": "Save Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save Results": {
      "main": [
        [
          {
            "node": "Audit Log",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Audit Log": {
      "main": [
        [
          {
            "node": "Format Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Response": {
      "main": [
        [
          {
            "node": "Return Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 0,
  "updatedAt": "2025-01-01T00:00:00.000Z",
  "versionId": "3"
}
