{
  "name": "Pentest V4 Cloud Scanner",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "pentest/v4/cloud",
        "options": {}
      },
      "name": "Cloud Scan Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [200, 300],
      "webhookId": "cloud-scan-v4"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT id, name, status, settings FROM projects WHERE id = '{{ $json.body.project_id }}'::uuid AND status = 'active'",
        "options": {}
      },
      "name": "Validate Project",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [420, 300],
      "credentials": {
        "postgres": {
          "id": "1",
          "name": "Postgres"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "project-exists",
              "leftValue": "={{ $json.id }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              }
            }
          ]
        },
        "options": {}
      },
      "name": "Project Valid?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [640, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ error: 'Project not found or inactive', project_id: $('Cloud Scan Webhook').first().json.body.project_id }) }}",
        "options": {}
      },
      "name": "Invalid Project Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [860, 450]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT sc.id, sc.username, sc.credential_type, sc.redis_key, sc.domain\nFROM secure_credentials sc\nWHERE sc.id = '{{ $('Cloud Scan Webhook').first().json.body.credential_id }}'::uuid\nAND sc.project_id = '{{ $('Cloud Scan Webhook').first().json.body.project_id }}'::uuid\nAND sc.credential_type LIKE 'azure_%'",
        "options": {}
      },
      "name": "Load Azure Credential",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [860, 200],
      "credentials": {
        "postgres": {
          "id": "1",
          "name": "Postgres"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "cred-exists",
              "leftValue": "={{ $json.id }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              }
            }
          ]
        },
        "options": {}
      },
      "name": "Credential Valid?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1080, 200]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ error: 'Azure credential not found', credential_id: $('Cloud Scan Webhook').first().json.body.credential_id }) }}",
        "options": {}
      },
      "name": "Invalid Credential Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1300, 350]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Check rate limits for cloud scans with row locking to prevent race condition\nWITH running_count AS (\n  SELECT COUNT(*) as cnt FROM scan_jobs \n  WHERE project_id = '{{ $('Cloud Scan Webhook').first().json.body.project_id }}'::uuid \n  AND status = 'running' AND scan_type LIKE 'cloud_%'\n  FOR UPDATE\n),\nhourly_count AS (\n  SELECT COUNT(*) as cnt FROM scan_jobs \n  WHERE project_id = '{{ $('Cloud Scan Webhook').first().json.body.project_id }}'::uuid \n  AND scan_type LIKE 'cloud_%' AND started_at > NOW() - INTERVAL '1 hour'\n)\nSELECT\n  CASE\n    WHEN (SELECT cnt FROM running_count) >= 2 THEN 'concurrent_limit'\n    WHEN (SELECT cnt FROM hourly_count) >= 10 THEN 'hourly_limit'\n    ELSE 'ok'\n  END as rate_status",
        "options": {}
      },
      "name": "Check Rate Limits",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [1300, 100],
      "credentials": {
        "postgres": {
          "id": "1",
          "name": "Postgres"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "rate-ok",
              "leftValue": "={{ $json.rate_status }}",
              "rightValue": "ok",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ]
        },
        "options": {}
      },
      "name": "Rate OK?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1520, 100]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ error: 'Rate limit exceeded', status: $json.rate_status }) }}",
        "options": {}
      },
      "name": "Rate Limit Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1740, 250]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO scan_jobs (project_id, scan_type, target, parameters, status)\nVALUES (\n  '{{ $('Cloud Scan Webhook').first().json.body.project_id }}'::uuid,\n  'cloud_{{ $('Cloud Scan Webhook').first().json.body.scan_mode }}',\n  '{{ $('Cloud Scan Webhook').first().json.body.tenant_id }}',\n  '{{ JSON.stringify($('Cloud Scan Webhook').first().json.body) }}'::jsonb,\n  'running'\n)\nRETURNING id",
        "options": {}
      },
      "name": "Create Scan Job",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [1740, 0],
      "credentials": {
        "postgres": {
          "id": "1",
          "name": "Postgres"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Build Azure CLI commands based on scan mode\nconst input = $('Cloud Scan Webhook').first().json.body;\nconst credential = $('Load Azure Credential').first().json;\nconst scanJobId = $input.first().json.id;\n\n// Validate and sanitize inputs\nfunction isValidUUID(str) {\n  if (!str) return false;\n  return /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(str);\n}\n\nfunction sanitizeForPath(str) {\n  if (!str) return '';\n  // Only allow alphanumeric and hyphens for paths\n  return String(str).replace(/[^a-zA-Z0-9\\-]/g, '');\n}\n\n// Validate tenant_id is a valid GUID\nconst tenantId = input.tenant_id;\nif (!isValidUUID(tenantId)) {\n  throw new Error('Invalid tenant_id format - must be a valid UUID');\n}\n\n// Sanitize scanJobId for safe path usage\nconst safeScanJobId = sanitizeForPath(scanJobId);\nif (!safeScanJobId) {\n  throw new Error('Invalid scan job ID');\n}\n\n// Validate scan_mode against allowed values\nconst allowedModes = ['aad-enum', 'resource-discovery', 'blob-scan', 'privilege-audit', 'keyvault-access', 'api-abuse', 'full-cloud'];\nconst scanMode = allowedModes.includes(input.scan_mode) ? input.scan_mode : 'full-cloud';\n\nconst outputDir = `/opt/recon-workspace/cloud_${safeScanJobId}`;\n\n// Commands array\nlet commands = [];\n\n// Always start with directory creation and auth\ncommands.push(`mkdir -p ${outputDir}`);\n\n// Authentication command (placeholder for actual creds from Redis)\nconst authCmd = `az login --service-principal -u \\\"$AZURE_CLIENT_ID\\\" -p \\\"$AZURE_CLIENT_SECRET\\\" --tenant ${tenantId} --output none`;\ncommands.push(authCmd);\n\n// Build mode-specific commands\nswitch (scanMode) {\n  case 'aad-enum':\n    commands.push(\n      `az ad user list --output json > ${outputDir}/users.json`,\n      `az ad group list --output json > ${outputDir}/groups.json`,\n      `az ad sp list --all --output json > ${outputDir}/service_principals.json`,\n      `az ad app list --all --output json > ${outputDir}/applications.json`\n    );\n    break;\n\n  case 'resource-discovery':\n    commands.push(\n      `az account subscription list --output json > ${outputDir}/subscriptions.json`,\n      `az resource list --output json > ${outputDir}/all_resources.json`,\n      `az storage account list --output json > ${outputDir}/storage_accounts.json`,\n      `az keyvault list --output json > ${outputDir}/keyvaults.json`,\n      `az vm list --output json > ${outputDir}/virtual_machines.json`,\n      `az network nsg list --output json > ${outputDir}/network_security_groups.json`,\n      `az sql server list --output json > ${outputDir}/sql_servers.json`\n    );\n    break;\n\n  case 'blob-scan':\n    commands.push(\n      `az storage account list --output json > ${outputDir}/storage_accounts.json`,\n      `echo '[]' > ${outputDir}/public_containers.json`,\n      `for acct in $(az storage account list --query '[].name' -o tsv); do az storage container list --account-name $acct --auth-mode login --output json 2>/dev/null | jq -c --arg acct \"$acct\" '.[] | . + {account: $acct}' >> ${outputDir}/containers_raw.json; done || true`,\n      `cat ${outputDir}/containers_raw.json | jq -s '.' > ${outputDir}/all_containers.json 2>/dev/null || echo '[]' > ${outputDir}/all_containers.json`\n    );\n    break;\n\n  case 'privilege-audit':\n    commands.push(\n      `az role assignment list --all --output json > ${outputDir}/role_assignments.json`,\n      `az role definition list --output json > ${outputDir}/role_definitions.json`,\n      `az ad sp list --all --query \"[?appOwnerOrganizationId=='${tenantId}']\" --output json > ${outputDir}/owned_service_principals.json`\n    );\n    break;\n\n  case 'keyvault-access':\n    commands.push(\n      `az keyvault list --output json > ${outputDir}/keyvaults.json`,\n      `echo '[]' > ${outputDir}/keyvault_access.json`,\n      `for vault in $(az keyvault list --query '[].name' -o tsv); do az keyvault show --name $vault --output json | jq -c '{name: .name, access_policies: .properties.accessPolicies}' >> ${outputDir}/vault_policies_raw.json; done || true`,\n      `cat ${outputDir}/vault_policies_raw.json | jq -s '.' > ${outputDir}/all_vault_policies.json 2>/dev/null || echo '[]' > ${outputDir}/all_vault_policies.json`\n    );\n    break;\n\n  case 'api-abuse':\n    // Graph API enumeration\n    commands.push(\n      `az rest --method GET --url 'https://graph.microsoft.com/v1.0/organization' --output json > ${outputDir}/organization.json || true`,\n      `az rest --method GET --url 'https://graph.microsoft.com/v1.0/domains' --output json > ${outputDir}/domains.json || true`,\n      `az rest --method GET --url 'https://graph.microsoft.com/v1.0/directoryRoles' --output json > ${outputDir}/directory_roles.json || true`\n    );\n    break;\n\n  case 'full-cloud':\n  default:\n    // Comprehensive scan - all modes\n    commands.push(\n      // Subscriptions & Resources\n      `az account subscription list --output json > ${outputDir}/subscriptions.json`,\n      `az resource list --output json > ${outputDir}/all_resources.json`,\n      // AAD\n      `az ad user list --output json > ${outputDir}/users.json`,\n      `az ad group list --output json > ${outputDir}/groups.json`,\n      `az ad sp list --all --output json > ${outputDir}/service_principals.json`,\n      `az ad app list --all --output json > ${outputDir}/applications.json`,\n      // Storage\n      `az storage account list --output json > ${outputDir}/storage_accounts.json`,\n      // Key Vaults\n      `az keyvault list --output json > ${outputDir}/keyvaults.json`,\n      // Compute\n      `az vm list --output json > ${outputDir}/virtual_machines.json`,\n      // Network\n      `az network nsg list --output json > ${outputDir}/network_security_groups.json`,\n      // IAM\n      `az role assignment list --all --output json > ${outputDir}/role_assignments.json`,\n      // ScoutSuite comprehensive scan\n      `scout azure --no-browser --report-dir ${outputDir}/scoutsuite 2>&1 | tee ${outputDir}/scoutsuite.log || true`\n    );\n    break;\n}\n\n// Logout at the end\ncommands.push(`az logout || true`);\n\nreturn [{\n  json: {\n    commands: commands,\n    output_dir: outputDir,\n    scan_job_id: scanJobId,\n    scan_mode: scanMode,\n    tenant_id: tenantId,\n    project_id: input.project_id,\n    credential_id: input.credential_id,\n    credential_type: credential.credential_type,\n    redis_key: credential.redis_key\n  }\n}];"
      },
      "name": "Build Cloud Commands",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1960, 0]
    },
    {
      "parameters": {
        "jsCode": "// Get credentials from Redis and set environment\nconst data = $input.first().json;\nconst redisKey = data.redis_key;\n\n// In production, fetch from Redis:\n// const credData = await redis.get(redisKey);\n// const decrypted = decrypt(credData);\n\n// For now, we'll use environment variables set in docker-compose\n// The actual credential retrieval would be done via HTTP Request to Redis\n\nreturn [{\n  json: {\n    ...data,\n    env_vars: {\n      AZURE_CLIENT_ID: '${AZURE_CLIENT_ID}',\n      AZURE_CLIENT_SECRET: '${AZURE_CLIENT_SECRET}',\n      AZURE_TENANT_ID: data.tenant_id\n    }\n  }\n}];"
      },
      "name": "Prepare Credentials",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2180, 0]
    },
    {
      "parameters": {
        "command": "={{ $json.commands.join(' && ') }}",
        "options": {
          "timeout": 600000
        }
      },
      "name": "Execute Cloud Scans",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [2400, 0]
    },
    {
      "parameters": {
        "jsCode": "// Parse cloud scan results and detect findings\nconst input = $('Prepare Credentials').first().json;\nconst outputDir = input.output_dir;\nconst projectId = input.project_id;\nconst tenantId = input.tenant_id;\nconst scanMode = input.scan_mode;\n\nconst findings = [];\nconst stats = {\n  users: 0,\n  groups: 0,\n  service_principals: 0,\n  resources: 0,\n  storage_accounts: 0,\n  keyvaults: 0,\n  role_assignments: 0\n};\n\n// Helper to safely parse JSON files\nfunction safeParseFile(filename) {\n  try {\n    const content = require('fs').readFileSync(`${outputDir}/${filename}`, 'utf8');\n    return JSON.parse(content);\n  } catch (e) {\n    return null;\n  }\n}\n\n// Parse AAD objects\nconst users = safeParseFile('users.json');\nif (users) {\n  stats.users = users.length;\n  // Check for guest users\n  const guests = users.filter(u => u.userType === 'Guest');\n  if (guests.length > 10) {\n    findings.push({\n      type: 'excessive_guests',\n      severity: 'medium',\n      title: `${guests.length} guest users in tenant`,\n      description: 'Large number of external guest accounts may increase risk',\n      remediation: 'Review and remove unnecessary guest accounts'\n    });\n  }\n}\n\nconst groups = safeParseFile('groups.json');\nif (groups) stats.groups = groups.length;\n\nconst sps = safeParseFile('service_principals.json');\nif (sps) {\n  stats.service_principals = sps.length;\n  // Check for SPs with passwords\n  const spsWithCreds = sps.filter(sp => sp.passwordCredentials && sp.passwordCredentials.length > 0);\n  if (spsWithCreds.length > 0) {\n    findings.push({\n      type: 'sp_password_creds',\n      severity: 'low',\n      title: `${spsWithCreds.length} service principals using password credentials`,\n      description: 'Password credentials are less secure than certificate credentials',\n      remediation: 'Consider migrating to certificate-based authentication'\n    });\n  }\n}\n\n// Parse resources\nconst resources = safeParseFile('all_resources.json');\nif (resources) stats.resources = resources.length;\n\nconst storageAccounts = safeParseFile('storage_accounts.json');\nif (storageAccounts) {\n  stats.storage_accounts = storageAccounts.length;\n  // Check for public access\n  const publicAccounts = storageAccounts.filter(sa => \n    sa.allowBlobPublicAccess === true || \n    sa.publicNetworkAccess === 'Enabled'\n  );\n  if (publicAccounts.length > 0) {\n    findings.push({\n      type: 'public_storage',\n      severity: 'high',\n      title: `${publicAccounts.length} storage accounts with public access`,\n      description: 'Storage accounts allowing public access may expose sensitive data',\n      remediation: 'Disable public blob access and restrict network access',\n      evidence: { accounts: publicAccounts.map(a => a.name) }\n    });\n  }\n  \n  // Check for HTTP-only\n  const httpOnly = storageAccounts.filter(sa => sa.enableHttpsTrafficOnly === false);\n  if (httpOnly.length > 0) {\n    findings.push({\n      type: 'storage_http',\n      severity: 'high',\n      title: `${httpOnly.length} storage accounts allowing HTTP traffic`,\n      description: 'HTTP traffic is unencrypted and vulnerable to interception',\n      remediation: 'Enable HTTPS-only traffic',\n      evidence: { accounts: httpOnly.map(a => a.name) }\n    });\n  }\n}\n\nconst keyvaults = safeParseFile('keyvaults.json');\nif (keyvaults) {\n  stats.keyvaults = keyvaults.length;\n  // Check for soft delete disabled\n  const noSoftDelete = keyvaults.filter(kv => \n    kv.properties && kv.properties.enableSoftDelete === false\n  );\n  if (noSoftDelete.length > 0) {\n    findings.push({\n      type: 'keyvault_no_soft_delete',\n      severity: 'medium',\n      title: `${noSoftDelete.length} Key Vaults without soft delete`,\n      description: 'Soft delete protects against accidental or malicious deletion',\n      remediation: 'Enable soft delete for all Key Vaults'\n    });\n  }\n}\n\n// Parse role assignments\nconst roleAssignments = safeParseFile('role_assignments.json');\nif (roleAssignments) {\n  stats.role_assignments = roleAssignments.length;\n  // Check for Owner/Contributor at subscription level\n  const privilegedRoles = roleAssignments.filter(ra =>\n    (ra.roleDefinitionName === 'Owner' || ra.roleDefinitionName === 'Contributor') &&\n    ra.scope && !ra.scope.includes('/resourceGroups/')\n  );\n  if (privilegedRoles.length > 5) {\n    findings.push({\n      type: 'excessive_privilege',\n      severity: 'high',\n      title: `${privilegedRoles.length} subscription-level Owner/Contributor assignments`,\n      description: 'Too many highly privileged role assignments at subscription scope',\n      remediation: 'Apply least privilege principle, use resource group scoped assignments'\n    });\n  }\n}\n\nreturn [{\n  json: {\n    scan_job_id: input.scan_job_id,\n    project_id: projectId,\n    tenant_id: tenantId,\n    scan_mode: scanMode,\n    output_dir: outputDir,\n    stats: stats,\n    findings: findings,\n    finding_count: findings.length\n  }\n}];"
      },
      "name": "Parse Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2620, 0]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Get or create tenant\nWITH tenant AS (\n  SELECT get_or_create_azure_tenant(\n    '{{ $json.project_id }}'::uuid,\n    '{{ $json.tenant_id }}',\n    NULL\n  ) as id\n)\nSELECT id FROM tenant",
        "options": {}
      },
      "name": "Upsert Tenant",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [2840, 0],
      "credentials": {
        "postgres": {
          "id": "1",
          "name": "Postgres"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Save cloud findings\n{{ $('Parse Results').first().json.findings.map(f => `\nINSERT INTO cloud_findings (\n  project_id, tenant_id, finding_type, severity, title, description, remediation, evidence\n) VALUES (\n  '${$('Parse Results').first().json.project_id}'::uuid,\n  '${$json.id}'::uuid,\n  '${f.type}',\n  '${f.severity}',\n  '${f.title.replace(/'/g, \"''\")}',\n  '${(f.description || '').replace(/'/g, \"''\")}',\n  '${(f.remediation || '').replace(/'/g, \"''\")}',\n  '${JSON.stringify(f.evidence || {})}'::jsonb\n);`).join('\\n') }}\n\n-- Update scan job as completed\nUPDATE scan_jobs SET\n  status = 'completed',\n  completed_at = NOW(),\n  result = '{{ JSON.stringify($('Parse Results').first().json.stats) }}'::jsonb\nWHERE id = '{{ $('Parse Results').first().json.scan_job_id }}'::uuid;",
        "options": {}
      },
      "name": "Save Findings",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [3060, 0],
      "credentials": {
        "postgres": {
          "id": "1",
          "name": "Postgres"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Log the scan in audit log\nINSERT INTO audit_log (project_id, action, entity_type, entity_id, details)\nVALUES (\n  '{{ $('Parse Results').first().json.project_id }}'::uuid,\n  'cloud_scan_completed',\n  'scan_job',\n  '{{ $('Parse Results').first().json.scan_job_id }}'::uuid,\n  '{{ JSON.stringify({ mode: $('Parse Results').first().json.scan_mode, findings: $('Parse Results').first().json.finding_count, stats: $('Parse Results').first().json.stats }) }}'::jsonb\n)",
        "options": {}
      },
      "name": "Audit Log",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [3280, 0],
      "credentials": {
        "postgres": {
          "id": "1",
          "name": "Postgres"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Generate cloud scan report\nconst results = $('Parse Results').first().json;\n\nlet report = `# Azure Cloud Security Scan Report\\n\\n`;\nreport += `**Tenant ID:** ${results.tenant_id}\\n`;\nreport += `**Scan Mode:** ${results.scan_mode}\\n`;\nreport += `**Scan Job:** ${results.scan_job_id}\\n\\n`;\n\nreport += `## Summary Statistics\\n\\n`;\nreport += `| Resource Type | Count |\\n`;\nreport += `|---------------|-------|\\n`;\nfor (const [key, value] of Object.entries(results.stats)) {\n  report += `| ${key.replace(/_/g, ' ')} | ${value} |\\n`;\n}\n\nreport += `\\n## Security Findings (${results.findings.length})\\n\\n`;\n\nif (results.findings.length === 0) {\n  report += `No critical security findings detected.\\n`;\n} else {\n  // Group by severity\n  const bySeverity = { critical: [], high: [], medium: [], low: [], info: [] };\n  for (const f of results.findings) {\n    if (bySeverity[f.severity]) {\n      bySeverity[f.severity].push(f);\n    }\n  }\n\n  for (const sev of ['critical', 'high', 'medium', 'low']) {\n    if (bySeverity[sev].length > 0) {\n      report += `### ${sev.toUpperCase()} (${bySeverity[sev].length})\\n\\n`;\n      for (const f of bySeverity[sev]) {\n        report += `#### ${f.title}\\n`;\n        report += `**Type:** ${f.type}\\n\\n`;\n        report += `${f.description}\\n\\n`;\n        report += `**Remediation:** ${f.remediation}\\n\\n`;\n        if (f.evidence && Object.keys(f.evidence).length > 0) {\n          report += `**Evidence:** \\`${JSON.stringify(f.evidence)}\\`\\n\\n`;\n        }\n        report += `---\\n\\n`;\n      }\n    }\n  }\n}\n\nreport += `\\n## Output Files\\n\\n`;\nreport += `Results saved to: \\`${results.output_dir}\\`\\n`;\n\nreturn [{\n  json: {\n    report: report,\n    scan_job_id: results.scan_job_id,\n    project_id: results.project_id,\n    tenant_id: results.tenant_id,\n    finding_count: results.finding_count,\n    stats: results.stats\n  }\n}];"
      },
      "name": "Generate Report",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3500, 0]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ success: true, scan_job_id: $json.scan_job_id, tenant_id: $json.tenant_id, findings: $json.finding_count, stats: $json.stats, report: $json.report }) }}",
        "options": {}
      },
      "name": "Success Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [3720, 0]
    }
  ],
  "connections": {
    "Cloud Scan Webhook": {
      "main": [
        [
          {
            "node": "Validate Project",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Project": {
      "main": [
        [
          {
            "node": "Project Valid?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Project Valid?": {
      "main": [
        [
          {
            "node": "Load Azure Credential",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Invalid Project Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Azure Credential": {
      "main": [
        [
          {
            "node": "Credential Valid?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Credential Valid?": {
      "main": [
        [
          {
            "node": "Check Rate Limits",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Invalid Credential Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Rate Limits": {
      "main": [
        [
          {
            "node": "Rate OK?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Rate OK?": {
      "main": [
        [
          {
            "node": "Create Scan Job",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Rate Limit Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Scan Job": {
      "main": [
        [
          {
            "node": "Build Cloud Commands",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Cloud Commands": {
      "main": [
        [
          {
            "node": "Prepare Credentials",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Credentials": {
      "main": [
        [
          {
            "node": "Execute Cloud Scans",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute Cloud Scans": {
      "main": [
        [
          {
            "node": "Parse Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Results": {
      "main": [
        [
          {
            "node": "Upsert Tenant",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upsert Tenant": {
      "main": [
        [
          {
            "node": "Save Findings",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save Findings": {
      "main": [
        [
          {
            "node": "Audit Log",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Audit Log": {
      "main": [
        [
          {
            "node": "Generate Report",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Report": {
      "main": [
        [
          {
            "node": "Success Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 0,
  "updatedAt": "2025-01-01T00:00:00.000Z",
  "versionId": "4"
}
