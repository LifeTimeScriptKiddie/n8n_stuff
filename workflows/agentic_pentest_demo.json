{
  "name": "Agentic Pentest Demo",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "pentest",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Pentest Input",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [200, 300],
      "webhookId": "pentest-demo"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://ollama:11434/api/generate",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ model: 'llama3.2', prompt: `You are a penetration testing automation assistant.\n\nUser input: \"${$json.body.target}\"\n\nDetermine what the target is:\n- IPv4 address?\n- Domain?\n- URL?\n- Company name?\n\nDecide which recon tools to run. Output a JSON plan ONLY.\nTools available:\n- subfinder -d <domain> -silent\n- amass enum -passive -d <domain>\n- nmap -sV -Pn -T4 --top-ports 100 <target>\n- nuclei -u <url> -severity medium,high,critical -silent\n- httpx -u <target> -silent -status-code -title -tech-detect\n- whois <domain>\n- dig ANY <domain>\n\nReturn JSON with the structure:\n{\n  \"target_type\": \"domain|ip|url|company\",\n  \"sanitized_target\": \"the actual target to scan\",\n  \"commands\": [\n    \"command 1\",\n    \"command 2\"\n  ]\n}\nNo commentary. No explanation. JSON only.`, stream: false }) }}",
        "options": {
          "timeout": 120000
        }
      },
      "id": "ollama-planner",
      "name": "AI Recon Planner",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [420, 300]
    },
    {
      "parameters": {
        "jsCode": "// Extract JSON from Ollama response\nconst response = $input.first().json.response;\n\n// Find JSON in the response (Ollama might include some text)\nlet jsonStr = response;\nconst jsonMatch = response.match(/\\{[\\s\\S]*\\}/);\nif (jsonMatch) {\n  jsonStr = jsonMatch[0];\n}\n\ntry {\n  const plan = JSON.parse(jsonStr);\n  \n  // Create output items for each command\n  const items = plan.commands.map((cmd, index) => ({\n    json: {\n      command: cmd,\n      index: index,\n      target_type: plan.target_type,\n      sanitized_target: plan.sanitized_target,\n      total_commands: plan.commands.length\n    }\n  }));\n  \n  return items;\n} catch (e) {\n  throw new Error(`Failed to parse AI response: ${e.message}\\nResponse was: ${response}`);\n}"
      },
      "id": "parse-plan",
      "name": "Parse Plan",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [640, 300]
    },
    {
      "parameters": {
        "batchSize": 1,
        "options": {}
      },
      "id": "split-batches",
      "name": "Loop Commands",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [860, 300]
    },
    {
      "parameters": {
        "command": "={{ $json.command }}",
        "options": {
          "timeout": 300000
        }
      },
      "id": "execute-cmd",
      "name": "Run Command",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [1080, 300]
    },
    {
      "parameters": {
        "jsCode": "// Aggregate all command results\nconst allItems = $input.all();\nconst results = allItems.map(item => ({\n  command: item.json.command,\n  stdout: item.json.stdout || '',\n  stderr: item.json.stderr || '',\n  exitCode: item.json.exitCode\n}));\n\nreturn [{\n  json: {\n    results: results,\n    target_type: allItems[0]?.json.target_type || 'unknown',\n    sanitized_target: allItems[0]?.json.sanitized_target || 'unknown'\n  }\n}];"
      },
      "id": "aggregate-results",
      "name": "Aggregate Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1300, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://ollama:11434/api/generate",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ model: 'llama3.2', prompt: `You are a senior penetration tester writing a security assessment report.\n\nTarget: ${$json.sanitized_target} (${$json.target_type})\n\nHere are the reconnaissance results from multiple tools:\n\n${$json.results.map(r => `### Command: ${r.command}\\nExit Code: ${r.exitCode}\\n\\nOutput:\\n${r.stdout.substring(0, 3000)}\\n${r.stderr ? 'Errors: ' + r.stderr.substring(0, 500) : ''}`).join('\\n\\n---\\n\\n')}\n\nWrite a concise offensive security report including:\n\n1. **Executive Summary** - Brief overview of findings\n2. **Target Classification** - What type of target and scope\n3. **Discovered Assets** - Subdomains, IPs, services found\n4. **Open Ports & Services** - What's exposed\n5. **Vulnerabilities Found** - Any issues from Nuclei or other tools\n6. **Risk Assessment** - High/Medium/Low findings\n7. **Recommended Next Steps** - What to investigate further\n\nOutput in clean Markdown format.`, stream: false }) }}",
        "options": {
          "timeout": 180000
        }
      },
      "id": "ollama-report",
      "name": "AI Generate Report",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1520, 300]
    },
    {
      "parameters": {
        "jsCode": "const report = $input.first().json.response;\n\nreturn [{\n  json: {\n    success: true,\n    report: report,\n    target: $('Aggregate Results').first().json.sanitized_target,\n    target_type: $('Aggregate Results').first().json.target_type,\n    commands_executed: $('Aggregate Results').first().json.results.length,\n    timestamp: new Date().toISOString()\n  }\n}];"
      },
      "id": "format-response",
      "name": "Format Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1740, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {}
      },
      "id": "respond-webhook",
      "name": "Return Report",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1960, 300]
    }
  ],
  "connections": {
    "Pentest Input": {
      "main": [
        [
          {
            "node": "AI Recon Planner",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Recon Planner": {
      "main": [
        [
          {
            "node": "Parse Plan",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Plan": {
      "main": [
        [
          {
            "node": "Loop Commands",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Commands": {
      "main": [
        [
          {
            "node": "Run Command",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Aggregate Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run Command": {
      "main": [
        [
          {
            "node": "Loop Commands",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate Results": {
      "main": [
        [
          {
            "node": "AI Generate Report",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Generate Report": {
      "main": [
        [
          {
            "node": "Format Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Response": {
      "main": [
        [
          {
            "node": "Return Report",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": ""
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 0,
  "updatedAt": "2025-01-01T00:00:00.000Z",
  "versionId": "1"
}
