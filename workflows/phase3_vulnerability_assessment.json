{
  "name": "Phase 3: Vulnerability Assessment",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "phase3-vulnerability-assessment",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Webhook: Start Phase 3",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [240, 500],
      "webhookId": "phase3-vulnerability-assessment"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT rs.*, sd.stealth_level, sd.rate_limit_per_sec, sd.max_concurrent_scans\nFROM recon_sessions rs\nJOIN scope_definitions sd ON rs.scope_file = sd.scope_name\nWHERE rs.session_id = '{{ $json.session_id }}'\nAND rs.status = 'phase2_completed'",
        "options": {}
      },
      "id": "load-session",
      "name": "Load Session Details",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [460, 500],
      "credentials": {
        "postgres": {
          "id": "1",
          "name": "PostgreSQL account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.session_id }}",
              "operation": "exists"
            }
          ]
        }
      },
      "id": "validate-session",
      "name": "Validate Session Ready",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [680, 500]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ {\"error\": \"Session not ready for Phase 3\", \"session_id\": $('Webhook: Start Phase 3').item.json.session_id} }}",
        "options": {
          "responseCode": 400
        }
      },
      "id": "error-session-not-ready",
      "name": "Error: Session Not Ready",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [900, 650]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE recon_sessions SET status = 'phase3_started', updated_at = NOW() WHERE session_id = '{{ $('Webhook: Start Phase 3').item.json.session_id }}'",
        "options": {}
      },
      "id": "update-session-phase3",
      "name": "Update Session: Phase 3 Started",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [900, 350],
      "credentials": {
        "postgres": {
          "id": "1",
          "name": "PostgreSQL account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO scan_checkpoints (session_id, phase, checkpoint_name, checkpoint_data, created_at)\nVALUES (\n  '{{ $('Webhook: Start Phase 3').item.json.session_id }}',\n  'phase3',\n  'vuln_assessment_started',\n  '{\"start_time\": \"{{ $now }}\"}'::jsonb,\n  NOW()\n)",
        "options": {}
      },
      "id": "checkpoint-phase3-start",
      "name": "Checkpoint: Phase 3 Start",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [1120, 350],
      "credentials": {
        "postgres": {
          "id": "1",
          "name": "PostgreSQL account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT DISTINCT url FROM http_services WHERE session_id = '{{ $('Webhook: Start Phase 3').item.json.session_id }}' AND status_code BETWEEN 200 AND 499",
        "options": {}
      },
      "id": "load-targets",
      "name": "Load HTTP Targets",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [1340, 350],
      "credentials": {
        "postgres": {
          "id": "1",
          "name": "PostgreSQL account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Create target list file for vulnerability scanning\nconst targets = $input.all().map(item => item.json.url);\nconst sessionId = $('Webhook: Start Phase 3').item.json.session_id;\nconst targetFile = `/tmp/targets_${sessionId}.txt`;\n\nconst fs = require('fs');\nfs.writeFileSync(targetFile, targets.join('\\n'));\n\nconsole.log(`Created target list with ${targets.length} URLs`);\n\nreturn [{\n  json: {\n    target_file: targetFile,\n    target_count: targets.length,\n    session_id: sessionId\n  }\n}];"
      },
      "id": "create-target-file",
      "name": "Create Target List File",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1560, 350]
    },
    {
      "parameters": {
        "command": "nuclei -l {{ $json.target_file }} -silent -json -severity critical,high,medium -rate-limit {{ $('Load Session Details').item.json.rate_limit_per_sec }} -bulk-size 25 -timeout 15 -max-host-error 10 -no-interactsh -o /tmp/nuclei_{{ $json.session_id }}.json && cat /tmp/nuclei_{{ $json.session_id }}.json"
      },
      "id": "nuclei-scan",
      "name": "Nuclei: Vulnerability Scanning",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [1780, 100],
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "command": "cat {{ $json.target_file }} | head -20 | while read url; do echo \"Testing: $url\"; ffuf -u \"$url/FUZZ\" -w /usr/share/wordlists/dirb/common.txt -mc 200,204,301,302,307,401,403 -fs 0 -t 10 -rate {{ $('Load Session Details').item.json.rate_limit_per_sec }} -timeout 10 -se -o /tmp/ffuf_$(echo $url | md5sum | cut -d' ' -f1).json 2>/dev/null || true; done && find /tmp -name 'ffuf_*.json' -exec cat {} \\; 2>/dev/null | head -5000"
      },
      "id": "ffuf-fuzz",
      "name": "ffuf: Directory Fuzzing",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [1780, 300],
      "alwaysOutputData": true,
      "continueOnFail": true
    },
    {
      "parameters": {
        "command": "subjack -w {{ $json.target_file }} -t 50 -timeout 30 -o /tmp/subjack_{{ $json.session_id }}.txt -ssl -v && cat /tmp/subjack_{{ $json.session_id }}.txt 2>/dev/null || echo 'No subdomain takeovers found'"
      },
      "id": "subjack-scan",
      "name": "subjack: Subdomain Takeover Detection",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [1780, 500],
      "alwaysOutputData": true,
      "continueOnFail": true
    },
    {
      "parameters": {
        "command": "cat {{ $json.target_file }} | head -50 | while read url; do echo \"Checking headers: $url\"; curl -sI -L --max-time 10 \"$url\" 2>/dev/null | grep -iE '(X-Frame-Options|Content-Security-Policy|X-Content-Type-Options|Strict-Transport-Security|X-XSS-Protection)' && echo \"URL: $url\" && echo '---' || true; done"
      },
      "id": "security-headers",
      "name": "Security Headers Analysis",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [1780, 700],
      "alwaysOutputData": true,
      "continueOnFail": true
    },
    {
      "parameters": {
        "command": "cat {{ $json.target_file }} | grep -E '^https://' | head -10 | while read url; do host=$(echo $url | sed 's|https://||' | sed 's|/.*||'); echo \"Testing SSL: $host\"; /opt/testssl.sh/testssl.sh --quiet --jsonfile /tmp/testssl_$(echo $host | md5sum | cut -d' ' -f1).json \"$host\" 2>/dev/null || true; done && find /tmp -name 'testssl_*.json' -exec cat {} \\; 2>/dev/null"
      },
      "id": "testssl-scan",
      "name": "testssl.sh: SSL/TLS Testing",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [1780, 900],
      "alwaysOutputData": true,
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Parse Nuclei JSON output line by line\nconst sessionId = $('Webhook: Start Phase 3').item.json.session_id;\nconst nucleiOutput = $input.first().json.stdout || '';\n\nconst results = [];\nconst lines = nucleiOutput.split('\\n');\n\nlines.forEach(line => {\n  if (!line.trim()) return;\n  \n  try {\n    const vuln = JSON.parse(line);\n    \n    // Calculate finding hash for deduplication\n    const crypto = require('crypto');\n    const findingString = `${vuln['template-id']}:${vuln.host}:${vuln.matched || ''}`;\n    const findingHash = crypto.createHash('sha256').update(findingString).digest('hex');\n    \n    results.push({\n      session_id: sessionId,\n      vuln_type: vuln['template-id'] || 'unknown',\n      severity: vuln.info?.severity || 'info',\n      host: vuln.host,\n      url: vuln.matched || vuln.host,\n      description: vuln.info?.name || vuln['template-id'],\n      details: {\n        matcher_name: vuln['matcher-name'],\n        template: vuln['template-id'],\n        tags: vuln.info?.tags || [],\n        reference: vuln.info?.reference || [],\n        matched_at: vuln['matched-at']\n      },\n      finding_hash: findingHash,\n      discovered_at: new Date().toISOString()\n    });\n  } catch (e) {\n    console.log('Failed to parse nuclei line:', line.substring(0, 100));\n  }\n});\n\nconsole.log(`Parsed ${results.length} Nuclei vulnerabilities`);\nreturn results.map(item => ({json: item}));"
      },
      "id": "parse-nuclei",
      "name": "Parse Nuclei Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2000, 100]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=WITH new_finding AS (\n  INSERT INTO vulnerability_findings (\n    session_id, vuln_type, severity, host, url, description, details, finding_hash, discovered_at, created_at\n  )\n  VALUES (\n    '{{ $json.session_id }}',\n    '{{ $json.vuln_type }}',\n    '{{ $json.severity }}',\n    '{{ $json.host }}',\n    '{{ $json.url }}',\n    '{{ $json.description }}',\n    '{{ JSON.stringify($json.details) }}'::jsonb,\n    '{{ $json.finding_hash }}',\n    '{{ $json.discovered_at }}',\n    NOW()\n  )\n  ON CONFLICT (finding_hash) DO NOTHING\n  RETURNING id\n)\nINSERT INTO finding_hashes (finding_hash, session_id, first_seen, last_seen, occurrence_count)\nVALUES (\n  '{{ $json.finding_hash }}',\n  '{{ $json.session_id }}',\n  NOW(),\n  NOW(),\n  1\n)\nON CONFLICT (finding_hash) DO UPDATE SET\n  last_seen = NOW(),\n  occurrence_count = finding_hashes.occurrence_count + 1",
        "options": {}
      },
      "id": "store-nuclei-findings",
      "name": "Store Nuclei Findings (Deduplicated)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [2220, 100],
      "credentials": {
        "postgres": {
          "id": "1",
          "name": "PostgreSQL account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parse ffuf fuzzing results\nconst sessionId = $('Webhook: Start Phase 3').item.json.session_id;\nconst ffufOutput = $input.first().json.stdout || '';\n\nconst results = [];\nconst lines = ffufOutput.split('\\n');\n\nlines.forEach(line => {\n  if (!line.trim() || !line.includes('{')) return;\n  \n  try {\n    const data = JSON.parse(line);\n    \n    if (data.results && Array.isArray(data.results)) {\n      data.results.forEach(result => {\n        const crypto = require('crypto');\n        const findingString = `directory_found:${result.url}:${result.status}`;\n        const findingHash = crypto.createHash('sha256').update(findingString).digest('hex');\n        \n        results.push({\n          session_id: sessionId,\n          vuln_type: 'directory_found',\n          severity: result.status === 200 ? 'info' : 'low',\n          host: new URL(result.url).host,\n          url: result.url,\n          description: `Directory/File Found: ${result.status}`,\n          details: {\n            status: result.status,\n            length: result.length,\n            words: result.words,\n            lines: result.lines\n          },\n          finding_hash: findingHash,\n          discovered_at: new Date().toISOString()\n        });\n      });\n    }\n  } catch (e) {\n    // Skip non-JSON lines\n  }\n});\n\nconsole.log(`Parsed ${results.length} ffuf findings`);\nreturn results.slice(0, 500).map(item => ({json: item}));"
      },
      "id": "parse-ffuf",
      "name": "Parse ffuf Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2000, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=INSERT INTO vulnerability_findings (\n  session_id, vuln_type, severity, host, url, description, details, finding_hash, discovered_at, created_at\n)\nVALUES (\n  '{{ $json.session_id }}',\n  '{{ $json.vuln_type }}',\n  '{{ $json.severity }}',\n  '{{ $json.host }}',\n  '{{ $json.url }}',\n  '{{ $json.description }}',\n  '{{ JSON.stringify($json.details) }}'::jsonb,\n  '{{ $json.finding_hash }}',\n  '{{ $json.discovered_at }}',\n  NOW()\n)\nON CONFLICT (finding_hash) DO NOTHING",
        "options": {}
      },
      "id": "store-ffuf-findings",
      "name": "Store Fuzzing Findings",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [2220, 300],
      "credentials": {
        "postgres": {
          "id": "1",
          "name": "PostgreSQL account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parse subjack output for subdomain takeover vulnerabilities\nconst sessionId = $('Webhook: Start Phase 3').item.json.session_id;\nconst subjackOutput = $input.first().json.stdout || '';\n\nconst results = [];\nconst lines = subjackOutput.split('\\n');\n\nlines.forEach(line => {\n  if (!line.trim() || line.includes('No subdomain takeovers')) return;\n  \n  // Look for subdomain takeover indicators\n  if (line.includes('vulnerable') || line.includes('takeover') || line.includes('[')  ) {\n    const crypto = require('crypto');\n    const findingString = `subdomain_takeover:${line}`;\n    const findingHash = crypto.createHash('sha256').update(findingString).digest('hex');\n    \n    // Extract domain from line\n    const domainMatch = line.match(/\\[([^\\]]+)\\]/);\n    const domain = domainMatch ? domainMatch[1] : 'unknown';\n    \n    results.push({\n      session_id: sessionId,\n      vuln_type: 'subdomain_takeover',\n      severity: 'high',\n      host: domain,\n      url: `https://${domain}`,\n      description: 'Potential Subdomain Takeover Detected',\n      details: {\n        raw_output: line.trim()\n      },\n      finding_hash: findingHash,\n      discovered_at: new Date().toISOString()\n    });\n  }\n});\n\nconsole.log(`Parsed ${results.length} subdomain takeover findings`);\nreturn results.map(item => ({json: item}));"
      },
      "id": "parse-subjack",
      "name": "Parse Subdomain Takeover Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2000, 500]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=INSERT INTO vulnerability_findings (\n  session_id, vuln_type, severity, host, url, description, details, finding_hash, discovered_at, created_at\n)\nVALUES (\n  '{{ $json.session_id }}',\n  '{{ $json.vuln_type }}',\n  '{{ $json.severity }}',\n  '{{ $json.host }}',\n  '{{ $json.url }}',\n  '{{ $json.description }}',\n  '{{ JSON.stringify($json.details) }}'::jsonb,\n  '{{ $json.finding_hash }}',\n  '{{ $json.discovered_at }}',\n  NOW()\n)\nON CONFLICT (finding_hash) DO NOTHING",
        "options": {}
      },
      "id": "store-subjack-findings",
      "name": "Store Takeover Findings",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [2220, 500],
      "credentials": {
        "postgres": {
          "id": "1",
          "name": "PostgreSQL account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parse security headers analysis\nconst sessionId = $('Webhook: Start Phase 3').item.json.session_id;\nconst headersOutput = $input.first().json.stdout || '';\n\nconst results = [];\nconst sections = headersOutput.split('---');\n\nlet currentUrl = '';\nconst missingHeaders = [];\n\nsections.forEach(section => {\n  const lines = section.split('\\n');\n  \n  lines.forEach(line => {\n    if (line.startsWith('URL: ')) {\n      currentUrl = line.replace('URL: ', '').trim();\n      // Check for missing security headers\n      const hasFrameOptions = section.includes('X-Frame-Options');\n      const hasCSP = section.includes('Content-Security-Policy');\n      const hasHSTS = section.includes('Strict-Transport-Security');\n      const hasContentType = section.includes('X-Content-Type-Options');\n      \n      const missing = [];\n      if (!hasFrameOptions) missing.push('X-Frame-Options');\n      if (!hasCSP) missing.push('Content-Security-Policy');\n      if (!hasHSTS) missing.push('Strict-Transport-Security');\n      if (!hasContentType) missing.push('X-Content-Type-Options');\n      \n      if (missing.length > 0 && currentUrl) {\n        const crypto = require('crypto');\n        const findingString = `missing_headers:${currentUrl}:${missing.join(',')}`;\n        const findingHash = crypto.createHash('sha256').update(findingString).digest('hex');\n        \n        results.push({\n          session_id: sessionId,\n          vuln_type: 'missing_security_headers',\n          severity: 'low',\n          host: new URL(currentUrl).host,\n          url: currentUrl,\n          description: `Missing Security Headers: ${missing.join(', ')}`,\n          details: {\n            missing_headers: missing\n          },\n          finding_hash: findingHash,\n          discovered_at: new Date().toISOString()\n        });\n      }\n    }\n  });\n});\n\nconsole.log(`Parsed ${results.length} security header findings`);\nreturn results.map(item => ({json: item}));"
      },
      "id": "parse-headers",
      "name": "Parse Security Headers",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2000, 700]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=INSERT INTO security_headers (session_id, url, missing_headers, analyzed_at, created_at)\nVALUES (\n  '{{ $json.session_id }}',\n  '{{ $json.url }}',\n  '{{ JSON.stringify($json.details.missing_headers) }}'::jsonb,\n  '{{ $json.discovered_at }}',\n  NOW()\n)\nON CONFLICT (session_id, url) DO UPDATE SET\n  missing_headers = EXCLUDED.missing_headers,\n  analyzed_at = EXCLUDED.analyzed_at",
        "options": {}
      },
      "id": "store-header-findings",
      "name": "Store Header Analysis",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [2220, 700],
      "credentials": {
        "postgres": {
          "id": "1",
          "name": "PostgreSQL account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parse testssl.sh JSON output\nconst sessionId = $('Webhook: Start Phase 3').item.json.session_id;\nconst testsslOutput = $input.first().json.stdout || '';\n\nconst results = [];\n\ntry {\n  // testssl.sh outputs multiple JSON objects, one per host\n  const jsonObjects = testsslOutput.split('\\n').filter(line => line.trim().startsWith('{'));\n  \n  jsonObjects.forEach(jsonStr => {\n    try {\n      const data = JSON.parse(jsonStr);\n      \n      // Look for SSL/TLS vulnerabilities\n      const vulns = [];\n      \n      if (data.scanResult && Array.isArray(data.scanResult)) {\n        data.scanResult.forEach(test => {\n          if (test.severity === 'HIGH' || test.severity === 'CRITICAL' || test.severity === 'MEDIUM') {\n            vulns.push({\n              test_id: test.id,\n              finding: test.finding,\n              severity: test.severity.toLowerCase()\n            });\n          }\n        });\n      }\n      \n      if (vulns.length > 0) {\n        const crypto = require('crypto');\n        const host = data.targetHost || 'unknown';\n        const findingString = `ssl_vuln:${host}:${vulns.map(v => v.test_id).join(',')}`;\n        const findingHash = crypto.createHash('sha256').update(findingString).digest('hex');\n        \n        results.push({\n          session_id: sessionId,\n          vuln_type: 'ssl_tls_vulnerability',\n          severity: vulns.some(v => v.severity === 'critical') ? 'critical' : 'high',\n          host: host,\n          url: `https://${host}`,\n          description: `SSL/TLS Issues Found: ${vulns.length} vulnerabilities`,\n          details: {\n            vulnerabilities: vulns,\n            protocols: data.protocols || []\n          },\n          finding_hash: findingHash,\n          discovered_at: new Date().toISOString()\n        });\n      }\n    } catch (e) {\n      console.log('Failed to parse testssl JSON object');\n    }\n  });\n} catch (e) {\n  console.log('testssl parsing error:', e.message);\n}\n\nconsole.log(`Parsed ${results.length} SSL/TLS findings`);\nreturn results.map(item => ({json: item}));"
      },
      "id": "parse-testssl",
      "name": "Parse SSL/TLS Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2000, 900]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=INSERT INTO ssl_results (session_id, host, vulnerabilities, protocols, tested_at, created_at)\nVALUES (\n  '{{ $json.session_id }}',\n  '{{ $json.host }}',\n  '{{ JSON.stringify($json.details.vulnerabilities) }}'::jsonb,\n  '{{ JSON.stringify($json.details.protocols) }}'::jsonb,\n  '{{ $json.discovered_at }}',\n  NOW()\n)\nON CONFLICT (session_id, host) DO UPDATE SET\n  vulnerabilities = EXCLUDED.vulnerabilities,\n  tested_at = EXCLUDED.tested_at",
        "options": {}
      },
      "id": "store-ssl-findings",
      "name": "Store SSL/TLS Analysis",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [2220, 900],
      "credentials": {
        "postgres": {
          "id": "1",
          "name": "PostgreSQL account"
        }
      }
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineAll"
      },
      "id": "wait-all-vuln-scans",
      "name": "Wait for All Vulnerability Scans",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2,
      "position": [2440, 500]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE recon_sessions SET status = 'phase3_completed', updated_at = NOW() WHERE session_id = '{{ $('Webhook: Start Phase 3').item.json.session_id }}'",
        "options": {}
      },
      "id": "update-session-phase3-complete",
      "name": "Update Session: Phase 3 Complete",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [2660, 500],
      "credentials": {
        "postgres": {
          "id": "1",
          "name": "PostgreSQL account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO scan_checkpoints (session_id, phase, checkpoint_name, checkpoint_data, created_at)\nVALUES (\n  '{{ $('Webhook: Start Phase 3').item.json.session_id }}',\n  'phase3',\n  'vuln_assessment_completed',\n  '{\"end_time\": \"{{ $now }}\"}'::jsonb,\n  NOW()\n)",
        "options": {}
      },
      "id": "checkpoint-phase3-complete",
      "name": "Checkpoint: Phase 3 Complete",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [2880, 500],
      "credentials": {
        "postgres": {
          "id": "1",
          "name": "PostgreSQL account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT \n  COUNT(*) as total_findings,\n  COUNT(*) FILTER (WHERE severity = 'critical') as critical_count,\n  COUNT(*) FILTER (WHERE severity = 'high') as high_count,\n  COUNT(*) FILTER (WHERE severity = 'medium') as medium_count,\n  COUNT(*) FILTER (WHERE severity = 'low') as low_count\nFROM vulnerability_findings \nWHERE session_id = '{{ $('Webhook: Start Phase 3').item.json.session_id }}'",
        "options": {}
      },
      "id": "count-vulnerabilities",
      "name": "Count Vulnerabilities by Severity",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [3100, 500],
      "credentials": {
        "postgres": {
          "id": "1",
          "name": "PostgreSQL account"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://n8n-recon:5678/webhook/phase4-reporting",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ { \"session_id\": $('Webhook: Start Phase 3').item.json.session_id, \"target\": $('Load Session Details').item.json.target, \"total_findings\": $('Count Vulnerabilities by Severity').item.json.total_findings, \"critical_count\": $('Count Vulnerabilities by Severity').item.json.critical_count, \"source\": \"phase3\" } }}",
        "options": {
          "timeout": 300000
        }
      },
      "id": "trigger-phase4",
      "name": "Trigger Phase 4",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [3320, 500],
      "notes": "Starts Phase 4: Analysis & Reporting after vulnerability assessment completes",
      "continueOnFail": true
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ {\n  \"status\": \"phase3_completed\",\n  \"session_id\": $('Webhook: Start Phase 3').item.json.session_id,\n  \"total_findings\": $('Count Vulnerabilities by Severity').item.json.total_findings,\n  \"critical\": $('Count Vulnerabilities by Severity').item.json.critical_count,\n  \"high\": $('Count Vulnerabilities by Severity').item.json.high_count,\n  \"medium\": $('Count Vulnerabilities by Severity').item.json.medium_count,\n  \"low\": $('Count Vulnerabilities by Severity').item.json.low_count,\n  \"phase4_triggered\": $('Trigger Phase 4').item.json.statusCode === 200,\n  \"message\": \"Vulnerability assessment completed successfully\"\n} }}",
        "options": {}
      },
      "id": "respond-success",
      "name": "Respond: Phase 3 Success",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [3540, 500]
    }
  ],
  "connections": {
    "Webhook: Start Phase 3": {
      "main": [
        [
          {
            "node": "Load Session Details",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Session Details": {
      "main": [
        [
          {
            "node": "Validate Session Ready",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Session Ready": {
      "main": [
        [
          {
            "node": "Update Session: Phase 3 Started",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error: Session Not Ready",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Session: Phase 3 Started": {
      "main": [
        [
          {
            "node": "Checkpoint: Phase 3 Start",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Checkpoint: Phase 3 Start": {
      "main": [
        [
          {
            "node": "Load HTTP Targets",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load HTTP Targets": {
      "main": [
        [
          {
            "node": "Create Target List File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Target List File": {
      "main": [
        [
          {
            "node": "Nuclei: Vulnerability Scanning",
            "type": "main",
            "index": 0
          },
          {
            "node": "ffuf: Directory Fuzzing",
            "type": "main",
            "index": 0
          },
          {
            "node": "subjack: Subdomain Takeover Detection",
            "type": "main",
            "index": 0
          },
          {
            "node": "Security Headers Analysis",
            "type": "main",
            "index": 0
          },
          {
            "node": "testssl.sh: SSL/TLS Testing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Nuclei: Vulnerability Scanning": {
      "main": [
        [
          {
            "node": "Parse Nuclei Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Nuclei Results": {
      "main": [
        [
          {
            "node": "Store Nuclei Findings (Deduplicated)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store Nuclei Findings (Deduplicated)": {
      "main": [
        [
          {
            "node": "Wait for All Vulnerability Scans",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ffuf: Directory Fuzzing": {
      "main": [
        [
          {
            "node": "Parse ffuf Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse ffuf Results": {
      "main": [
        [
          {
            "node": "Store Fuzzing Findings",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store Fuzzing Findings": {
      "main": [
        [
          {
            "node": "Wait for All Vulnerability Scans",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "subjack: Subdomain Takeover Detection": {
      "main": [
        [
          {
            "node": "Parse Subdomain Takeover Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Subdomain Takeover Results": {
      "main": [
        [
          {
            "node": "Store Takeover Findings",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store Takeover Findings": {
      "main": [
        [
          {
            "node": "Wait for All Vulnerability Scans",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "Security Headers Analysis": {
      "main": [
        [
          {
            "node": "Parse Security Headers",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Security Headers": {
      "main": [
        [
          {
            "node": "Store Header Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store Header Analysis": {
      "main": [
        [
          {
            "node": "Wait for All Vulnerability Scans",
            "type": "main",
            "index": 3
          }
        ]
      ]
    },
    "testssl.sh: SSL/TLS Testing": {
      "main": [
        [
          {
            "node": "Parse SSL/TLS Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse SSL/TLS Results": {
      "main": [
        [
          {
            "node": "Store SSL/TLS Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store SSL/TLS Analysis": {
      "main": [
        [
          {
            "node": "Wait for All Vulnerability Scans",
            "type": "main",
            "index": 4
          }
        ]
      ]
    },
    "Wait for All Vulnerability Scans": {
      "main": [
        [
          {
            "node": "Update Session: Phase 3 Complete",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Session: Phase 3 Complete": {
      "main": [
        [
          {
            "node": "Checkpoint: Phase 3 Complete",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Checkpoint: Phase 3 Complete": {
      "main": [
        [
          {
            "node": "Count Vulnerabilities by Severity",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Count Vulnerabilities by Severity": {
      "main": [
        [
          {
            "node": "Trigger Phase 4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Trigger Phase 4": {
      "main": [
        [
          {
            "node": "Respond: Phase 3 Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "pinData": {},
  "versionId": "1"
}
